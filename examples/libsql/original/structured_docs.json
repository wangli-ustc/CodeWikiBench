{
  "title": "libsql",
  "description": "Documentation for libsql",
  "content": {},
  "metadata": {
    "type": "root",
    "path": "/home/anhnh/CodeWiki-Benchmarking-System/data/libsql/original/docs"
  },
  "subpages": [
    {
      "title": "Libsql-server admin API documentation",
      "description": null,
      "content": {
        "Routes": "```\nPOST /v1/namespaces/:namespace/create\n```\n\nCreate a namespace named `:namespace`.\nbody:\n\n```\n{\n    \"dump_url\"?: string,\n}\n```\n\n```\nDELETE /v1/namespaces/:namespace\n```\n\nDelete the namespace named `:namespace`.\n\n```\nPOST /v1/namespaces/:namespace/fork/:to\n```\n\nFork `:namespace` into new namespace `:to`"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 0]"
    },
    {
      "title": "Build and run sqld",
      "description": null,
      "content": {
        "Running sqld": "You can simply run launch the executable with no command line arguments to run\nan instance of sqld. By default, sqld listens on 127.0.0.1 port 8080 and\npersists database data in a directory `./data.sqld`.\n\nUse the `--help` flag to discover how to change its runtime behavior.",
        "Query sqld": "You can query sqld using one of the provided [client\nlibraries](../libsql-server#client-libraries).\n\nYou can also use the [turso cli](https://docs.turso.tech/reference/turso-cli) to connect to the sqld instance:\n\n```\nturso db shell http://127.0.0.1:8080\n```",
        "Download a prebuilt binary": "The [libsql-server release page](https://github.com/tursodatabase/libsql/releases) for this repository lists released versions of sqld\nalong with downloads for macOS and Linux.",
        "Build and install with Homebrew": {
          "1. Add the tap `libsql/sqld` to Homebrew": "```\nbrew tap libsql/sqld\n```",
          "2. Install the formulae `sqld`": "```\nbrew install sqld\n```\n\nThis builds and installs the binary `sqld` into `$HOMEBREW_PREFIX/bin/sqld`,\nwhich should be in your PATH.",
          "3. Verify that `sqld` works": "```\nsqld --help\n```"
        },
        "Using a prebuilt Docker image": "The sqld release process publishes a Docker image to the GitHub Container\nRegistry. The URL is <https://ghcr.io/tursodatabase/libsql-server>. You can run the latest image locally\non port 8080 with the following:\n\n```\ndocker run -p 8080:8080 -d ghcr.io/tursodatabase/libsql-server:latest\n```\n\nOr you can run a specific version using one of the [sqld container release\ntags](https://github.com/tursodatabase/libsql/pkgs/container/libsql-server) in the following form for version X.Y.Z:\n\n```\ndocker run -p 8080:8080 -d ghcr.io/tursodatabase/libsql-server:vX.Y.Z\n```",
        "Build from source using Docker / Podman": {
          "1. Clone this repo": "Clone this repo using your preferred mechanism. You may want to use one of the\n[sqld release tags].",
          "2. Build with Docker": "Run the following to build a Docker image named \"libsql/sqld\" tagged with\nversion \"latest\".\n\n```\ndocker build -t libsql/sqld:latest .\n```",
          "3. Verify the build": "Check that sqld built successfully using its --help flag:\n\n```\ndocker container run \\\n  --rm \\\n  -i \\\n  libsql/sqld \\\n  /bin/sqld --help\n```",
          "4. Create a data volume": "The following will create a volume named `sqld-data` that sqld uses to persist\ndatabase files.\n\n```\ndocker volume create sqld-data\n```",
          "5. Run sqld in a container": "The following uses the built image to create and run a new container named\n`sqld`, attaching the `sqld-data` volume to it, and exposing its port 8080\nlocally:\n\n```\ndocker container run \\\n  -d \\\n  --name sqld \\\n  -v sqld-data:/var/lib/sqld \\\n  -p 127.0.0.1:8080:8080 \\\n  libsql/sqld:latest\n```\n\n8080 is the default port for the sqld HTTP service that handles client queries.\nWith this container running, you can use the URL `http://127.0.0.1:8080` or\n`ws://127.0.0.1:8080` to configure one of the libSQL client SDKs for local\ndevelopment.",
          "6. Configure sqld with environment variables": "In the sqld output using `--help` from step 3, you saw the names of command line\nflags along with the names of environment variables (look for \"env:\") used to\nconfigure the way sqld works."
        },
        "Build from source using Rust": {
          "1. Clone this repo": "Clone this repo using your preferred mechanism. You may want to use one of the\n[sqld release tags].\n\nChange to the `libsql-server` directory.",
          "2. Build with cargo": "```\ncargo build\n```\n\nThe sqld binary will be in `./target/debug/sqld`.",
          "3. Verify the build": "Check that sqld built successfully using its --help flag:\n\n```\n./target/debug/sqld --help\n```",
          "4. Run sqld with all defaults": "The following starts sqld, taking the following defaults:\n\n['Local files stored in the directory `./data.sqld`', 'Client HTTP requests on 127.0.0.1:8080']\n\n```\n./target/debug/sqld\n```\n\n8080 is the default port for the sqld HTTP service that handles client queries.\nWith this container running, you can use the URL `http://127.0.0.1:8080` or\n`ws://127.0.0.1:8080` to configure one of the libSQL client SDKs for local\ndevelopment.",
          "5. Run tests (optional)": "```\ncargo xtask test\n```\n\n[sqld container release tags]: https://github.com/libsql/sqld/pkgs/container/sqld\n[sqld release tags]: https://github.com/libsql/sqld/releases"
        }
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 1]"
    },
    {
      "title": "Sqld consistency model",
      "description": null,
      "content": {
        "Building on top of sqlite": "SQLite offers a strictly serializable consistency model. Since sqld is built on top of it, it inherits some of its properties.",
        "Transactional consistency": "Any transaction in sqld is equivalent to SQLite transaction. When a transaction is opened, on the primary or replicas alike, the view that the transaction get is \"frozen\" is time. Any write performed by a transaction is at the same time immediately visible to itself, as well as completely isolated from any other ongoing transactions. Therefore, sqld offers serializable transactions",
        "Real-time guarantees": "All operations occurring on the primary are linearizable. However, there is no guarantee that changes made to the primary are immediately visible to all replicas. Sqld guarantees that a process (connection) will always see its write. Given that the primary is linearizable, it means that a process is guaranteed to see all writes that happened on the primary up until (at least) the last write performed by the process. This is not true for two distinct processes on the same replica, however, that can potentially read two different points in time. For example, a read for process A on the replica might return immediately returning some state, while a read on process B issued at the same time would need to wait to sync with the primary.\n\nNote that reads on a replica are monotonic: once a value has been witnessed, only a value at least as recent can be witnessed on any subsequent read.\n\nThere are no global ordering guarantees provided by sqld: any two instances needn't be in sync at any time."
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 2]"
    },
    {
      "title": "Overview",
      "description": null,
      "content": {
        "Logical Architecture": {
          "Reads": "Clients initiate reads by using the `sqlite3_exec()` API, for example, to perform a `SELECT` query.\nThe client sends messages over the network to a replica server, which performs the `SELECT` query on its local database, and sends back the results over the network.\nThe replica also periodically polls the primary server for WAL updates to refresh the database.\n\n```\nsequenceDiagram\n    autonumber\n    participant Client\n    participant Replica\n    participant Primary\n    Client->>Replica: SQL SELECT\n    Replica->>Client: SQL result set\n    Replica->>Primary: Request WAL updates\n    Primary->>Replica: WAL entries\n```",
          "Writes": "Clients initiate writes with, for example, the `sqlite3_exec()` API by performing a `INSERT`, `UPDATE`, or `DELETE` SQL statement.\nThe primary server is responsible for writes.\nThe client sends writes to the primary server or a replica. If a replica receives a write, it delegates the write to the primary server.\nThe primary server either performs the write against its local `libSQL` database or processes it via `mvSQLite`, which uses FoundationDB.\n\n```\nsequenceDiagram\n    autonumber\n    participant Client\n    participant Primary\n    participant mvSQLite\n    Client->>Primary: SQL INSERT\n    Server->>mvSQLite: WAL\n```"
        },
        "Server": "The server architecture uses the service design pattern and uses `tower` as an interface. Tower provides middleware that we can reuse, and the design implements a clear separation of concern. Service is isolated and composable, which is a desirable property.\n\nHere is a simplified architecture diagram:\n\n```\nclassDiagram\n    Server --|> PgConnectionFactory\n    PgConnectionFactory --|> SchedulerService\n\n    class Server {\n    }\n\n    class PgConnectionFactory {\n    }\n\n    class SchedulerService {\n    }\n```\n\n`Server::serve` takes a `Service` (in fact, a Service factory), and calls the passed service with all incoming socket connections. The server runs the connections.\n\nThe `PgConnectionFactory` service takes a service factory that responds to `Query` requests and drives the Postgres wire protocol.\n\nThe `SchedulerServiceFactory` creates `SchedulerService`s that respond to `Query` requests, and schedule them to be performed."
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 3]"
    },
    {
      "title": "Docker image quick reference",
      "description": null,
      "content": {
        "Launch a primary instance": "```\ndocker run --name some-sqld -p 8080:8080 -ti \\\n    -e SQLD_NODE=primary \\\n    ghcr.io/tursodatabase/libsql-server:latest\n```",
        "Launch a replica instance": "```\ndocker run --name some-sqld-replica -p 8081:8080 -ti \\\n    -e SQLD_NODE=replica \\\n    -e SQLD_PRIMARY_URL=https://<host>:<port> \\\n    ghcr.io/tursodatabase/libsql-server:latest\n```",
        "Running on Apple Silicon": "```\ndocker run --name some-sqld  -p 8080:8080 -ti \\\n    -e SQLD_NODE=primary \\\n    --platform linux/amd64 \\\n    ghcr.io/tursodatabase/libsql-server:latest\n```\n\n_Note: the latest images for arm64 are available under the tag\n`ghcr.io/tursodatabase/libsql-server:latest-arm`, however for tagged versions,\nand stable releases please use the x86_64 versions via Rosetta._",
        "Docker Repository": "[https://github.com/tursodatabase/libsql/pkgs/container/libsql-server](https://github.com/tursodatabase/libsql/pkgs/container/libsql-server)"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 4]"
    },
    {
      "title": "The Hrana protocol specification (version 1)",
      "description": null,
      "content": {
        "Motivation": "This protocol aims to provide several benefits over the Postgres wire protocol:\n\n['Works in edge runtimes: WebSockets are available in all edge runtimes\\n(Cloudflare Workers, Deno Deploy, Lagon), but general TCP sockets are not\\n(notably, sockets are not supported by Cloudflare Workers).', 'Fast cold start: the Postgres wire protocol requires [at least two\\nroundtrips][pgwire-flow] before the client can send queries, but Hrana needs\\njust a single roundtrip introduced by the WebSocket protocol. (In both cases,\\nadditional roundtrips might be necessary due to TLS.)', 'Multiplexing: a single Hrana connection can open multiple SQL streams, so an\\napplication needs to open just a single connection even if it handles multiple\\nconcurrent requests.', 'Simplicity: Hrana is a simple protocol, so a client needs few lines of\\ncode. This is important on edge runtimes that impose hard limits on code size\\n(usually just a few MB).']\n\n[pgwire-flow]: https://www.postgresql.org/docs/current/protocol-flow.html",
        "Usage": "The Hrana protocol is intended to be used in one of two ways:\n\n['Connecting to `sqld`: edge functions and other clients can connect directly\\nto `sqld` using Hrana, because it has native support for the protocol. This is\\nthe approach with lowest latency, because no software in the middle is\\nnecessary.', 'Connecting to SQLite through a proxy: this allows edge functions\\nto efficiently connect to an existing SQLite databases.']",
        "Overview": "The protocol runs on top of the [WebSocket protocol][rfc6455] as a subprotocol\n`hrana1`. The client includes `hrana1` in the `Sec-WebSocket-Protocol` request\nheader in the opening handshake, and the server replies with `hrana1` in the\nsame response header. Future versions of the Hrana protocol will be negotiated\nas different WebSocket subprotocols.\n\n[rfc6455]: https://www.rfc-editor.org/rfc/rfc6455\n\nThe client starts the connection by sending a _hello_ message, which\nauthenticates the client to the server. The server responds with either a\nconfirmation or with an error message, closing the connection. The client can\nchoose not to wait for the confirmation and immediately send further messages to\nreduce latency.\n\nA single connection can host an arbitrary number of _streams_. A stream\ncorresponds to a \"session\" in PostgreSQL or a \"connection\" in SQLite: SQL\nstatements in a stream are executed sequentially and can affect stream-specific\nstate such as transactions (with SQL `BEGIN` or `SAVEPOINT`). In effect, one\nHrana connection works as a \"connection pool\" in traditional SQL servers.\n\nAfter a stream is opened, the client can execute SQL _statements_ on it. For the\npurposes of this protocol, the statements are arbitrary strings with optional\nparameters. The protocol can thus work with any SQL dialect.\n\nTo reduce the number of roundtrips, the protocol supports batches of statements\nthat are executed conditionally, based on success or failure of previous\nstatements. This mechanism is used to implement non-interactive transactions in\na single roundtrip.",
        "Messages": {
          "Hello": "```\ntype HelloMsg = {\n    \"type\": \"hello\",\n    \"jwt\": string | null,\n}\n```\n\nThe `hello` message is sent as the first message by the client. It authenticates\nthe client to the server using the [Json Web Token (JWT)][rfc7519] passed in the\n`jwt` field. If no authentication is required (which might be useful for\ndevelopment and debugging, or when authentication is performed by other means,\nsuch as with mutual TLS), the `jwt` field might be set to `null`.\n\n[rfc7519]: https://www.rfc-editor.org/rfc/rfc7519\n\n```\ntype HelloOkMsg = {\n    \"type\": \"hello_ok\",\n}\n\ntype HelloErrorMsg = {\n    \"type\": \"hello_error\",\n    \"error\": Error,\n}\n```\n\nThe server waits for the `hello` message from the client and responds with a\n`hello_ok` message if the client can proceed, or with a `hello_error` message\ndescribing the failure.\n\nThe client may choose not to wait for a response to its `hello` message before\nsending more messages to save a network roundtrip. If the server responds with\n`hello_error`, it must ignore all further messages sent by the client and it\nshould close the WebSocket immediately.",
          "Request/response": "```\ntype RequestMsg = {\n    \"type\": \"request\",\n    \"request_id\": int32,\n    \"request\": Request,\n}\n```\n\nAfter sending the `hello` message, the client can start sending `request`\nmessages. The client uses requests to open SQL streams and execute statements on\nthem. The client assigns an identifier to every request, which is then used to\nmatch a response to the request.\n\n```\ntype ResponseOkMsg = {\n    \"type\": \"response_ok\",\n    \"request_id\": int32,\n    \"response\": Response,\n}\n\ntype ResponseErrorMsg = {\n    \"type\": \"response_error\",\n    \"request_id\": int32,\n    \"error\": Error,\n}\n```\n\nWhen the server receives a `request` message, it must eventually send either a\n`response_ok` with the response or a `response_error` that describes a failure.\nThe response from the server includes the same `request_id` that was provided by\nthe client in the request. The server can send the responses in arbitrary order.\n\nThe request ids are arbitrary 32-bit signed integers, the server does not\ninterpret them in any way.\n\nThe server should limit the number of outstanding requests to a reasonable\nvalue, and stop receiving messages when this limit is reached. This will cause\nthe TCP flow control to kick in and apply back-pressure to the client. On the\nother hand, the client should always receive messages, to avoid deadlock.",
          "Errors": "```\ntype Error = {\n    \"message\": string,\n    \"code\"?: string | null,\n}\n```\n\nWhen a server refuses to accept a client `hello` or fails to process a\n`request`, it responds with a message that describes the error. The `message`\nfield contains an English human-readable description of the error. The `code`\ncontains a machine-readable error code.\n\nIf either peer detects that the protocol has been violated, it should close the\nWebSocket with an appropriate WebSocket close code and reason. Some examples of\nprotocol violations include:\n\n['Text message that is not a valid JSON.', 'Unrecognized `ClientMsg` or `ServerMsg` (the field `type` is unknown or\\nmissing)', 'Client receives a `ResponseOkMsg` or `ResponseErrorMsg` with a `request_id`\\nthat has not been sent in a `RequestMsg` or that has already received a\\nresponse.']"
        },
        "Requests": {
          "Open stream": "```\ntype OpenStreamReq = {\n    \"type\": \"open_stream\",\n    \"stream_id\": int32,\n}\n\ntype OpenStreamResp = {\n    \"type\": \"open_stream\",\n}\n```\n\nThe client uses the `open_stream` request to open an SQL stream, which is then\nused to execute SQL statements. The streams are identified by arbitrary 32-bit\nsigned integers assigned by the client.\n\nThe client can optimistically send follow-up requests on a stream before it\nreceives the response to its `open_stream` request. If the server receives a\nrequest that refers to a stream that failed to open, it should respond with an\nerror, but it should not close the connection.\n\nEven if the `open_stream` request returns an error, the stream id is still\nconsidered as used, and the client cannot reuse it until it sends a\n`close_stream` request.\n\nThe server can impose a reasonable limit to the number of streams opened at the\nsame time.",
          "Close stream": "```\ntype CloseStreamReq = {\n    \"type\": \"close_stream\",\n    \"stream_id\": int32,\n}\n\ntype CloseStreamResp = {\n    \"type\": \"close_stream\",\n}\n```\n\nWhen the client is done with a stream, it should close it using the\n`close_stream` request. The client can safely reuse the stream id after it\nreceives the response.\n\nThe client should close even streams for which the `open_stream` request\nreturned an error.",
          "Execute a statement": "```\ntype ExecuteReq = {\n    \"type\": \"execute\",\n    \"stream_id\": int32,\n    \"stmt\": Stmt,\n}\n\ntype ExecuteResp = {\n    \"type\": \"execute\",\n    \"result\": StmtResult,\n}\n```\n\nThe client sends an `execute` request to execute an SQL statement on a stream.\nThe server responds with the result of the statement.\n\n```\ntype Stmt = {\n    \"sql\": string,\n    \"args\"?: Array<Value>,\n    \"named_args\"?: Array<NamedArg>,\n    \"want_rows\": boolean,\n}\n\ntype NamedArg = {\n    \"name\": string,\n    \"value\": Value,\n}\n```\n\nA statement contains the SQL text in `sql` and arguments.\n\nThe arguments in `args` are bound to parameters in the SQL statement by\nposition. The arguments in `named_args` are bound to parameters by name.\n\nFor SQLite, the names of arguments include the prefix sign (`:`, `@` or `$`). If\nthe name of the argument does not start with this prefix, the server will try to\nguess the correct prefix. If an argument is specified both as a positional\nargument and as a named argument, the named argument should take precedence.\n\nIt is an error if the request specifies an argument that is not expected by the\nSQL statement, or if the request does not specify an argument that is expected\nby the SQL statement. Some servers may not support specifying both positional\nand named arguments.\n\nThe `want_rows` field specifies whether the client is interested in the rows\nproduced by the SQL statement. If it is set to `false`, the server should always\nreply with no rows, even if the statement produced some.\n\nThe SQL text should contain just a single statement. Issuing multiple statements\nseparated by a semicolon is not supported.\n\n```\ntype StmtResult = {\n    \"cols\": Array<Col>,\n    \"rows\": Array<Array<Value>>,\n    \"affected_row_count\": int32,\n    \"last_insert_rowid\": string | null,\n}\n\ntype Col = {\n    \"name\": string | null,\n}\n```\n\nThe result of executing an SQL statement contains information about the returned\ncolumns in `cols` and the returned rows in `rows` (the array is empty if the\nstatement did not produce any rows or if `want_rows` was `false` in the request).\n\n`affected_row_count` counts the number of rows that were changed by the\nstatement. This is meaningful only if the statement was an INSERT, UPDATE or\nDELETE, and the value is otherwise undefined.\n\n`last_insert_rowid` is the ROWID of the last successful insert into a rowid\ntable. The rowid value is a 64-bit signed integer encoded as a string. For\nother statements, the value is undefined.",
          "Execute a batch": "```\ntype BatchReq = {\n    \"type\": \"batch\",\n    \"stream_id\": int32,\n    \"batch\": Batch,\n}\n\ntype BatchResp = {\n    \"type\": \"batch\",\n    \"result\": BatchResult,\n}\n```\n\nThe `batch` request runs a batch of statements on a stream. The server responds\nwith the result of the batch execution.\n\n```\ntype Batch = {\n    \"steps\": Array<BatchStep>,\n}\n\ntype BatchStep = {\n    \"condition\"?: BatchCond | null,\n    \"stmt\": Stmt,\n}\n\ntype BatchResult = {\n    \"step_results\": Array<StmtResult | null>,\n    \"step_errors\": Array<Error | null>,\n}\n```\n\nA batch is a list of steps (statements) which are always executed sequentially.\nIf the `condition` of a step is present and evaluates to false, the statement is\nskipped.\n\nThe batch result contains the results or errors of statements from each step.\nFor the step in `steps[i]`, `step_results[i]` contains the result of the\nstatement if the statement was executed and succeeded, and `step_errors[i]`\ncontains the error if the statement was executed and failed. If the statement\nwas skipped because its condition evaluated to false, both `step_results[i]` and\n`step_errors[i]` will be `null`.\n\n```\ntype BatchCond =\n    | { \"type\": \"ok\", \"step\": int32 }\n    | { \"type\": \"error\", \"step\": int32 }\n    | { \"type\": \"not\", \"cond\": BatchCond }\n    | { \"type\": \"and\", \"conds\": Array<BatchCond> }\n    | { \"type\": \"or\", \"conds\": Array<BatchCond> }\n```\n\nConditions are expressions that evaluate to true or false:\n\n['`ok` evaluates to true if the `step` (referenced by its 0-based index) was\\nexecuted successfully. If the statement was skipped, this condition evaluates to\\nfalse.', '`error` evaluates to true if the `step` (referenced by its 0-based index) has\\nproduced an error. If the statement was skipped, this condition evaluates to\\nfalse.', '`not` evaluates `cond` and returns the logical negative.', '`and` evaluates `conds` and returns the logical conjunction of them.', '`or` evaluates `conds` and returns the logical disjunction of them.']",
          "Values": "```\ntype Value =\n    | { \"type\": \"null\" }\n    | { \"type\": \"integer\", \"value\": string }\n    | { \"type\": \"float\", \"value\": number }\n    | { \"type\": \"text\", \"value\": string }\n    | { \"type\": \"blob\", \"base64\": string }\n```\n\nValues passed as arguments to SQL statements and returned in rows are one of\nsupported types:\n\n['`null`: the SQL NULL value', '`integer`: a 64-bit signed integer, its `value` is a string to avoid losing\\nprecision, because some JSON implementations treat all numbers as 64-bit floats', '`float`: a 64-bit float', '`text`: a UTF-8 text string', '`blob`: a binary blob with base64-encoded value']\n\nThese types exactly correspond to SQLite types. In the future, the protocol\nmight be extended with more types for compatibility with Postgres.",
          "Ordering": "The protocol allows the server to reorder the responses: it is not necessary to\nsend the responses in the same order as the requests. However, the server must\nprocess requests related to a single stream id in order.\n\nFor example, this means that a client can send an `open_stream` request\nimmediately followed by a batch of `execute` requests on that stream and the\nserver will always process them in correct order."
        }
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 5]"
    },
    {
      "title": "The Hrana protocol specification (version 2)",
      "description": null,
      "content": {
        "Version negotiation": "The Hrana protocol version 2 uses a WebSocket subprotocol `hrana2`. The\nWebSocket subprotocol negotiation allows the client and server to use version 2\nof the protocol if both peers support it, but fall back to version 1 if the\nclient or the server don't support version 2.",
        "Messages": {
          "Hello": "The `hello` message has the same format as in version 1. The client must send it\nas the first message, but in version 2, the client can also send it again\nanytime during the lifetime of the connection to reauthenticate, by providing a\nnew JWT.\n\nThis feature was introduced because, in long-living connections, the JWT used to\nauthenticate the client may expire and the server may terminate the connection.\nUsing this feature, the client can provide a fresh JWT, thus keeping the\nconnection properly authenticated."
        },
        "Requests": {
          "Store an SQL text on the server": "```\ntype StoreSqlReq = {\n    \"type\": \"store_sql\",\n    \"sql_id\": int32,\n    \"sql\": string,\n}\n\ntype StoreSqlResp = {\n    \"type\": \"store_sql\",\n}\n```\n\nThe `store_sql` request stores an SQL text on the server. The client can then\nrefer to this SQL text in other requests by its id, instead of repeatedly\nsending the same string over the network.\n\nSQL text ids are arbitrary 32-bit signed integers assigned by the client. It is\nan error if the client tries to store an SQL text with an id which is already in\nuse.",
          "Close a stored SQL text": "```\ntype CloseSqlReq = {\n    \"type\": \"close_sql\",\n    \"sql_id\": int32,\n}\n\ntype CloseSqlResp = {\n    \"type\": \"close_sql\",\n}\n```\n\nThe `close_sql` request can be used to delete an SQL text stored on the server\nwith `store_sql`. The client can safely reuse the SQL text id after it receives\nthe response.\n\nIt is not an error if the client attempts to close a SQL text id that is not\nused.",
          "Execute a sequence of SQL statements": "```\ntype SequenceReq = {\n    \"type\": \"sequence\",\n    \"stream_id\": int32,\n    \"sql\"?: string | null,\n    \"sql_id\"?: int32 | null,\n}\n\ntype SequenceResp = {\n    \"type\": \"sequence\",\n}\n```\n\nThe `sequence` request executes a sequence of SQL statements separated by\nsemicolons on the stream given by `stream_id`. `sql` or `sql_id` specify the SQL\ntext; exactly one of these fields must be specified.\n\nAny rows returned by the statements are ignored. If any statement fails, the\nsubsequent statements are not executed and the request returns an error\nresponse.",
          "Describe a statement": "```\ntype DescribeReq = {\n    \"type\": \"describe\",\n    \"stream_id\": int32,\n    \"sql\"?: string | null,\n    \"sql_id\"?: int32 | null,\n}\n\ntype DescribeResp = {\n    \"type\": \"describe\",\n    \"result\": DescribeResult,\n}\n```\n\nThe `describe` request is used to parse and analyze a SQL statement. `stream_id`\nspecifies the stream on which the statement is parsed. `sql` or `sql_id` specify\nthe SQL text: exactly one of these two fields must be specified, `sql` passes\nthe SQL directly as a string, while `sql_id` refers to a SQL text previously\nstored with `store_sql`. In the response, `result` contains the result of\ndescribing a statement.\n\n```\ntype DescribeResult = {\n    \"params\": Array<DescribeParam>,\n    \"cols\": Array<DescribeCol>,\n    \"is_explain\": boolean,\n    \"is_readonly\": boolean,\n}\n```\n\nIn the result, `is_explain` is true if the statement was an `EXPLAIN` statement,\nand `is_readonly` is true if the statement does not modify the database.\n\n```\ntype DescribeParam = {\n    \"name\": string | null,\n}\n```\n\nInformation about parameters of the statement is returned in `params`. SQLite\nindexes parameters from 1, so the first object in the `params` array describes\nparameter 1.\n\nFor each parameter, the `name` field specifies the name of the parameter. For\nparameters of the form `?NNN`, `:AAA`, `@AAA` and `$AAA`, the name includes the\ninitial `?`, `:`, `@` or `$` character. Parameters of the form `?` are nameless,\ntheir `name` is `null`.\n\nIt is also possible that some parameters are not referenced in the statement, in\nwhich case the `name` is also `null`.\n\n```\ntype DescribeCol = {\n    \"name\": string,\n    \"decltype\": string | null,\n}\n```\n\nInformation about columns of the statement is returned in `cols`.\n\nFor each column, `name` specifies the name assigned by the SQL `AS` clause. For\ncolumns without `AS` clause, the name is not specified.\n\nFor result columns that directly originate from tables in the database,\n`decltype` specifies the declared type of the column. For other columns (such as\nresults of expressions), `decltype` is `null`."
        },
        "Other changes": {
          "Statement": "```\ntype Stmt = {\n    \"sql\"?: string | undefined,\n    \"sql_id\"?: int32 | undefined,\n    \"args\"?: Array<Value>,\n    \"named_args\"?: Array<NamedArg>,\n    \"want_rows\"?: boolean,\n}\n```\n\nIn version 2 of the protocol, the SQL text of a statement can be specified\neither by passing a string directly in the `sql` field, or by passing SQL text\nid that has previously been stored with the `store_sql` request. Exactly one of\n`sql` and `sql_id` must be passed.\n\nAlso, the `want_rows` field is now optional and defaults to `true`.",
          "Statement result": "```\ntype Col = {\n    \"name\": string | null,\n    \"decltype\": string | null,\n}\n```\n\nIn version 2 of the protocol, the column descriptor in the statement result also\nincludes the declared type of the column (if available)."
        }
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 6]"
    },
    {
      "title": "The Hrana protocol specification (version 3)",
      "description": null,
      "content": {
        "Overview": {
          "Variants (WebSocket / HTTP)": "The protocol has two variants:\n\n['Hrana over WebSocket, which uses WebSocket as the underlying protocol.\\nMultiple streams can be multiplexed over a single WebSocket.', 'Hrana over HTTP, which communicates with the server using HTTP requests. This\\nis less efficient than WebSocket, but HTTP is the only reliable protocol in\\nsome environments.']\n\nEach of these variants is described later.",
          "Encoding": "The protocol has two encodings:\n\n['[JSON][rfc8259] is the canonical encoding, backward compatible with Hrana 1\\nand 2.', 'Protobuf ([Protocol Buffers][protobuf]) is a more compact binary encoding,\\nintroduced in Hrana 3.']\n\n[rfc8259]: https://datatracker.ietf.org/doc/html/rfc8259\n[protobuf]: https://protobuf.dev/\n\nThis document defines protocol structures in JSON and specifies the schema using\nTypeScript type notation. The Protobuf schema is described in proto3 syntax in\nan appendix.\n\nThe encoding is negotiated between the server and client. This process depends\non the variant (WebSocket or HTTP) and is described later. All Hrana 3 servers\nmust support both JSON and Protobuf; clients can choose which encodings to\nsupport and use.\n\nBoth encodings support forward compatibility: when a peer (client or server)\nreceives a protocol structure that includes an unrecognized field (object\nproperty in JSON or a message field in Protobuf), it must ignore this field."
        },
        "Hrana over WebSocket": {
          "Version and encoding negotiation": "The version of the protocol and the encoding is negotiated as a WebSocket\nsubprotocol: the client includes a list of supported subprotocols in the\n`Sec-WebSocket-Protocol` request header in the opening handshake, and the server\nreplies with the selected subprotocol in the same response header.\n\nThe negotiation mechanism provides backward compatibility with older versions of\nthe Hrana protocol and forward compatibility with newer versions.\n\n[rfc6455]: https://www.rfc-editor.org/rfc/rfc6455\n\nThe WebSocket subprotocols defined in all Hrana versions are as follows:\n\n| Subprotocol | Version | Encoding |\n|-------------|---------|----------|\n| `hrana1`    |       1 |     JSON |\n| `hrana2`    |       2 |     JSON |\n| `hrana3`    |       3 |     JSON |\n| `hrana3-protobuf` | 3 | Protobuf |\n\nThis document describes version 3 of the Hrana protocol. Versions 1 and 2 are\ndescribed in their own specifications.\n\nVersion 3 of Hrana over WebSocket is designed to be a strict superset of\nversions 1 and 2: every server that implements Hrana 3 over WebSocket also\nimplements versions 1 and 2 and should accept clients that indicate subprotocol\n`hrana1` or `hrana2`.",
          "Overview": "The client starts the connection by sending a _hello_ message, which\nauthenticates the client to the server. The server responds with either a\nconfirmation or with an error message, closing the connection. The client can\nchoose not to wait for the confirmation and immediately send further messages to\nreduce latency.\n\nA single connection can host an arbitrary number of streams. In effect, one\nHrana connection works as a \"connection pool\" in traditional SQL servers.\n\nAfter a stream is opened, the client can execute SQL statements on it. For the\npurposes of this protocol, the statements are arbitrary strings with optional\nparameters.\n\nTo reduce the number of roundtrips, the protocol supports batches of statements\nthat are executed conditionally, based on success or failure of previous\nstatements. Clients can use this mechanism to implement non-interactive\ntransactions in a single roundtrip.",
          "Messages": {
            "Hello": "```\ntype HelloMsg = {\n    \"type\": \"hello\",\n    \"jwt\": string | null,\n}\n```\n\nThe `hello` message is sent as the first message by the client. It authenticates\nthe client to the server using the [Json Web Token (JWT)][rfc7519] passed in the\n`jwt` field. If no authentication is required (which might be useful for\ndevelopment and debugging, or when authentication is performed by other means,\nsuch as with mutual TLS), the `jwt` field might be set to `null`.\n\n[rfc7519]: https://www.rfc-editor.org/rfc/rfc7519\n\nThe client can also send the `hello` message again anytime during the lifetime\nof the connection to reauthenticate, by providing a new JWT. If the provided JWT\nexpires and the client does not provide a new one in a `hello` message, the\nserver may terminate the connection.\n\n```\ntype HelloOkMsg = {\n    \"type\": \"hello_ok\",\n}\n\ntype HelloErrorMsg = {\n    \"type\": \"hello_error\",\n    \"error\": Error,\n}\n```\n\nThe server waits for the `hello` message from the client and responds with a\n`hello_ok` message if the client can proceed, or with a `hello_error` message\ndescribing the failure.\n\nThe client may choose not to wait for a response to its `hello` message before\nsending more messages to save a network roundtrip. If the server responds with\n`hello_error`, it must ignore all further messages sent by the client and it\nshould close the WebSocket immediately.",
            "Request/response": "```\ntype RequestMsg = {\n    \"type\": \"request\",\n    \"request_id\": int32,\n    \"request\": Request,\n}\n```\n\nAfter sending the `hello` message, the client can start sending `request`\nmessages. The client uses requests to open SQL streams and execute statements on\nthem. The client assigns an identifier to every request, which is then used to\nmatch a response to the request.\n\nThe `Request` structure represents the payload of the request and is defined\nlater.\n\n```\ntype ResponseOkMsg = {\n    \"type\": \"response_ok\",\n    \"request_id\": int32,\n    \"response\": Response,\n}\n\ntype ResponseErrorMsg = {\n    \"type\": \"response_error\",\n    \"request_id\": int32,\n    \"error\": Error,\n}\n```\n\nWhen the server receives a `request` message, it must eventually send either a\n`response_ok` with the response or a `response_error` that describes a failure.\nThe response from the server includes the same `request_id` that was provided by\nthe client in the request. The server can send the responses in arbitrary order.\n\nThe request ids are arbitrary 32-bit signed integers, the server does not\ninterpret them in any way.\n\nThe server should limit the number of outstanding requests to a reasonable\nvalue, and stop receiving messages when this limit is reached. This will cause\nthe TCP flow control to kick in and apply back-pressure to the client. On the\nother hand, the client should always receive messages, to avoid deadlock."
          },
          "Requests": {
            "Open stream": "```\ntype OpenStreamReq = {\n    \"type\": \"open_stream\",\n    \"stream_id\": int32,\n}\n\ntype OpenStreamResp = {\n    \"type\": \"open_stream\",\n}\n```\n\nThe client uses the `open_stream` request to open an SQL stream, which is then\nused to execute SQL statements. The streams are identified by arbitrary 32-bit\nsigned integers assigned by the client.\n\nThe client can optimistically send follow-up requests on a stream before it\nreceives the response to its `open_stream` request. If the server receives a\nrequest that refers to a stream that failed to open, it should respond with an\nerror, but it should not close the connection.\n\nEven if the `open_stream` request returns an error, the stream id is still\nconsidered as used, and the client cannot reuse it until it sends a\n`close_stream` request.\n\nThe server can impose a reasonable limit to the number of streams opened at the\nsame time.\n\n['This request was introduced in Hrana 1.']",
            "Close stream": "```\ntype CloseStreamReq = {\n    \"type\": \"close_stream\",\n    \"stream_id\": int32,\n}\n\ntype CloseStreamResp = {\n    \"type\": \"close_stream\",\n}\n```\n\nWhen the client is done with a stream, it should close it using the\n`close_stream` request. The client can safely reuse the stream id after it\nreceives the response.\n\nThe client should close even streams for which the `open_stream` request\nreturned an error.\n\nIf there is an open cursor for the stream, the cursor is closed together with\nthe stream.\n\n['This request was introduced in Hrana 1.']",
            "Execute a statement": "```\ntype ExecuteReq = {\n    \"type\": \"execute\",\n    \"stream_id\": int32,\n    \"stmt\": Stmt,\n}\n\ntype ExecuteResp = {\n    \"type\": \"execute\",\n    \"result\": StmtResult,\n}\n```\n\nThe client sends an `execute` request to execute an SQL statement on a stream.\nThe server responds with the result of the statement. The `Stmt` and\n`StmtResult` structures are defined later.\n\nIf the statement fails, the server responds with an error response (message of\ntype `\"response_error\"`).\n\n['This request was introduced in Hrana 1.']",
            "Execute a batch": "```\ntype BatchReq = {\n    \"type\": \"batch\",\n    \"stream_id\": int32,\n    \"batch\": Batch,\n}\n\ntype BatchResp = {\n    \"type\": \"batch\",\n    \"result\": BatchResult,\n}\n```\n\nThe `batch` request runs a batch of statements on a stream. The server responds\nwith the result of the batch execution.\n\nIf a statement in the batch fails, the error is returned inside the\n`BatchResult` structure in a normal response (message of type `\"response_ok\"`).\nHowever, if the server encounters a serious error that prevents it from\nexecuting the batch, it responds with an error response (message of type\n`\"response_error\"`).\n\n['This request was introduced in Hrana 1.']",
            "Open a cursor executing a batch": "```\ntype OpenCursorReq = {\n    \"type\": \"open_cursor\",\n    \"stream_id\": int32,\n    \"cursor_id\": int32,\n    \"batch\": Batch,\n}\n\ntype OpenCursorResp = {\n    \"type\": \"open_cursor\",\n}\n```\n\nThe `open_cursor` request runs a batch of statements like the `batch` request,\nbut instead of returning all statement results in the request response, it opens\na _cursor_ which the client can then use to read the results incrementally.\n\nThe `cursor_id` is an arbitrary 32-bit integer id assigned by the client. This\nid must be unique for the given connection and must not be used by another\ncursor that was not yet closed using the `close_cursor` request.\n\nEven if the `open_cursor` request returns an error, the cursor id is still\nconsidered as used, and the client cannot reuse it until it sends a\n`close_cursor` request.\n\nAfter the `open_cursor` request, the client must not send more requests on the\nstream until the cursor is closed using the `close_cursor` request.\n\n['This request was introduced in Hrana 3.']",
            "Close a cursor": "```\ntype CloseCursorReq = {\n    \"type\": \"close_cursor\",\n    \"cursor_id\": int32,\n}\n\ntype CloseCursorResp = {\n    \"type\": \"close_cursor\",\n}\n```\n\nThe `close_cursor` request closes a cursor opened by an `open_cursor` request\nand allows the server to release resources and continue processing other\nrequests for the given stream.\n\n['This request was introduced in Hrana 3.']",
            "Fetch entries from a cursor": "```\ntype FetchCursorReq = {\n    \"type\": \"fetch_cursor\",\n    \"cursor_id\": int32,\n    \"max_count\": uint32,\n}\n\ntype FetchCursorResp = {\n    \"type\": \"fetch_cursor\",\n    \"entries\": Array<CursorEntry>,\n    \"done\": boolean,\n}\n```\n\nThe `fetch_cursor` request reads data from a cursor previously opened with the\n`open_cursor` request. The cursor data is encoded as a sequence of entries\n(`CursorEntry` structure). `max_count` in the request specifies the maximum\nnumber of entries that the client wants to receive in the response; however, the\nserver may decide to send fewer entries.\n\nIf the `done` field in the response is set to true, then the cursor is finished\nand all subsequent calls to `fetch_cursor` are guaranteed to return zero\nentries. The client should then close the cursor by sending the `close_cursor`\nrequest.\n\nIf the `cursor_id` refers to a cursor for which the `open_cursor` request\nreturned an error, and the cursor hasn't yet been closed with `close_cursor`,\nthen the server should return an error, but it must not close the connection\n(i.e., this is not a protocol error).\n\n['This request was introduced in Hrana 3.']",
            "Store an SQL text on the server": "```\ntype StoreSqlReq = {\n    \"type\": \"store_sql\",\n    \"sql_id\": int32,\n    \"sql\": string,\n}\n\ntype StoreSqlResp = {\n    \"type\": \"store_sql\",\n}\n```\n\nThe `store_sql` request stores an SQL text on the server. The client can then\nrefer to this SQL text in other requests by its id, instead of repeatedly\nsending the same string over the network.\n\nSQL text ids are arbitrary 32-bit signed integers assigned by the client. It is\na protocol error if the client tries to store an SQL text with an id which is\nalready in use.\n\n['This request was introduced in Hrana 2.']",
            "Close a stored SQL text": "```\ntype CloseSqlReq = {\n    \"type\": \"close_sql\",\n    \"sql_id\": int32,\n}\n\ntype CloseSqlResp = {\n    \"type\": \"close_sql\",\n}\n```\n\nThe `close_sql` request can be used to delete an SQL text stored on the server\nwith `store_sql`. The client can safely reuse the SQL text id after it receives\nthe response.\n\nIt is not an error if the client attempts to close a SQL text id that is not\nused.\n\n['This request was introduced in Hrana 2.']",
            "Execute a sequence of SQL statements": "```\ntype SequenceReq = {\n    \"type\": \"sequence\",\n    \"stream_id\": int32,\n    \"sql\"?: string | null,\n    \"sql_id\"?: int32 | null,\n}\n\ntype SequenceResp = {\n    \"type\": \"sequence\",\n}\n```\n\nThe `sequence` request executes a sequence of SQL statements separated by\nsemicolons on the stream given by `stream_id`. `sql` or `sql_id` specify the SQL\ntext; exactly one of these fields must be specified.\n\nAny rows returned by the statements are ignored. If any statement fails, the\nsubsequent statements are not executed and the request returns an error\nresponse.\n\n['This request was introduced in Hrana 2.']",
            "Describe a statement": "```\ntype DescribeReq = {\n    \"type\": \"describe\",\n    \"stream_id\": int32,\n    \"sql\"?: string | null,\n    \"sql_id\"?: int32 | null,\n}\n\ntype DescribeResp = {\n    \"type\": \"describe\",\n    \"result\": DescribeResult,\n}\n```\n\nThe `describe` request is used to parse and analyze a SQL statement. `stream_id`\nspecifies the stream on which the statement is parsed. `sql` or `sql_id` specify\nthe SQL text: exactly one of these two fields must be specified, `sql` passes\nthe SQL directly as a string, while `sql_id` refers to a SQL text previously\nstored with `store_sql`. In the response, `result` contains the result of\ndescribing a statement.\n\n['This request was introduced in Hrana 2.']",
            "Get the autocommit state": "```\ntype GetAutocommitReq = {\n    \"type\": \"get_autocommit\",\n    \"stream_id\": int32,\n}\n\ntype GetAutocommitResp = {\n    \"type\": \"get_autocommit\",\n    \"is_autocommit\": bool,\n}\n```\n\nThe `get_autocommit` request can be used to check whether the stream is in\nautocommit state (not inside an explicit transaction).\n\n['This request was introduced in Hrana 3.']"
          },
          "Errors": "If either peer detects that the protocol has been violated, it should close the\nWebSocket with an appropriate WebSocket close code and reason. Some examples of\nprotocol violations include:\n\n['Text message payload that is not a valid JSON.', 'Data frame type that does not match the negotiated encoding (i.e., binary frame when\\nthe encoding is JSON or a text frame when the encoding is Protobuf).', 'Unrecognized `ClientMsg` or `ServerMsg` (the field `type` is unknown or\\nmissing)', 'Client receives a `ResponseOkMsg` or `ResponseErrorMsg` with a `request_id`\\nthat has not been sent in a `RequestMsg` or that has already received a\\nresponse.']",
          "Ordering": "The protocol allows the server to reorder the responses: it is not necessary to\nsend the responses in the same order as the requests. However, the server must\nprocess requests related to a single stream id in order.\n\nFor example, this means that a client can send an `open_stream` request\nimmediately followed by a batch of `execute` requests on that stream and the\nserver will always process them in correct order."
        },
        "Hrana over HTTP": {
          "Overview": "HTTP is a stateless protocol, so there is no concept of a connection like in the\nWebSocket protocol. However, Hrana needs to expose stateful streams, so it needs\nto ensure that requests on the same stream are tied together.\n\nThis is accomplished by the use of a baton, which is similar to a session cookie.\nThe server returns a baton in every response to a request on the stream, and the\nclient then needs to include the baton in the subsequent request. The client\nmust serialize the requests on a stream: it must wait for a response to the\nprevious request before sending next request on the same stream.\n\nThe server can also optionally specify a different URL that the client should\nuse for the requests on the stream. This can be used to ensure that stream\nrequests are \"sticky\" and reach the same server.\n\nIf the client terminates without closing a stream, the server has no way of\nfinding this out: with Hrana over WebSocket, the WebSocket connection is closed\nand the server can close the streams that belong to this connection, but there\nis no connection in Hrana over HTTP. Therefore, the server will close streams\nafter a short period of inactivity, to make sure that abandoned streams don't\naccumulate on the server.",
          "Version and encoding negotiation": "With Hrana over HTTP, the client indicates the Hrana version and encoding in the\nURI path of the HTTP request. The client can check whether the server supports a\ngiven Hrana version by sending an HTTP request (described later).",
          "Endpoints": {
            "Check support for version 3 (JSON)": "```\nGET v3\n```\n\nIf the server supports version 3 of Hrana over HTTP with JSON encoding, it\nshould return a 2xx response to this request.",
            "Check support for version 3 (Protobuf)": "```\nGET v3-protobuf\n```\n\nIf the server supports version 3 of Hrana over HTTP with Protobuf encoding, it\nshould return a 2xx response to this request.",
            "Execute a pipeline of requests (JSON)": "```\nPOST v3/pipeline\n-> JSON: PipelineReqBody\n<- JSON: PipelineRespBody\n```\n\n```\ntype PipelineReqBody = {\n    \"baton\": string | null,\n    \"requests\": Array<StreamRequest>,\n}\n\ntype PipelineRespBody = {\n    \"baton\": string | null,\n    \"base_url\": string | null,\n    \"results\": Array<StreamResult>\n}\n\ntype StreamResult =\n    | StreamResultOk\n    | StreamResultError\n\ntype StreamResultOk = {\n    \"type\": \"ok\",\n    \"response\": StreamResponse,\n}\n\ntype StreamResultError = {\n    \"type\": \"error\",\n    \"error\": Error,\n}\n```\n\nThe `v3/pipeline` endpoint is used to execute a pipeline of requests on a\nstream. `baton` in the request specifies the stream. If the client sets `baton`\nto `null`, the server should create a new stream.\n\nServer responds with another `baton` value in the response. If the `baton` value\nin the response is `null`, it means that the server has closed the stream. The\nclient must use this value to refer to this stream in the next request (the\n`baton` in the response should be different from the `baton` in the request).\nThis forces the client to issue the requests serially: it must wait for the\nresponse from a previous `pipeline` request before issuing another request on\nthe same stream.\n\nThe server should ensure that the `baton` values are unpredictable and\nunforgeable, for example by cryptographically signing them.\n\nIf the `base_url` in the response is not `null`, the client should use this URL\nwhen sending further requests on this stream. If it is `null`, the client should\nuse the same URL that it has used for the previous request. The `base_url`\nmust be an absolute URL with \"http\" or \"https\" scheme.\n\nThe `requests` array in the request specifies a sequence of stream requests that\nshould be executed on the stream. The server executes them in order and returns\nthe results in the `results` array in the response. Result is either a success\n(`type` set to `\"ok\"`) or an error (`type` set to `\"error\"`). The server always\nexecutes all requests, even if some of them return errors.",
            "Execute a pipeline of requests (Protobuf)": "```\nPOST v3-protobuf/pipeline\n-> Protobuf: PipelineReqBody\n<- Protobuf: PipelineRespBody\n```\n\nThe `v3-protobuf/pipeline` endpoint is the same as `v3/pipeline`, but it encodes\nthe request and response body using Protobuf.",
            "Execute a batch using a cursor (JSON)": "```\nPOST v3/cursor\n-> JSON: CursorReqBody\n<- line of JSON: CursorRespBody\n   lines of JSON: CursorEntry\n```\n\n```\ntype CursorReqBody = {\n    \"baton\": string | null,\n    \"batch\": Batch,\n}\n\ntype CursorRespBody = {\n    \"baton\": string | null,\n    \"base_url\": string | null,\n}\n```\n\nThe `v3/cursor` endpoint executes a batch of statements on a stream using a\ncursor, so the results can be streamed from the server to the client.\n\nThe HTTP response is composed of JSON structures separated with a newline. The\nfirst line contains the `CursorRespBody` structure, and the following lines\ncontain `CursorEntry` structures, which encode the result of the batch.\n\nThe `baton` field in the request and the `baton` and `base_url` fields in the\nresponse have the same meaning as in the `v3/pipeline` endpoint.",
            "Execute a batch using a cursor (Protobuf)": "```\nPOST v3-protobuf/cursor\n-> Protobuf: CursorReqBody\n<- length-delimited Protobuf: CursorRespBody\n   length-delimited Protobufs: CursorEntry\n```\n\nThe `v3-protobuf/cursor` endpoint is the same as `v3/cursor` endpoint, but the\nrequest and response are encoded using Protobuf.\n\nIn the response body, the structures are prefixed with a length delimiter: a\nProtobuf variant that encodes the length of the structure. The first structure is\n`CursorRespBody`, followed by an arbitrary number of `CursorEntry` structures."
          },
          "Requests": {
            "Close stream": "```\ntype CloseStreamReq = {\n    \"type\": \"close\",\n}\n\ntype CloseStreamResp = {\n    \"type\": \"close\",\n}\n```\n\nThe `close` request closes the stream. It is an error if the client tries to\nexecute more requests on the same stream.\n\n['This request was introduced in Hrana 2.']",
            "Execute a statement": "```\ntype ExecuteStreamReq = {\n    \"type\": \"execute\",\n    \"stmt\": Stmt,\n}\n\ntype ExecuteStreamResp = {\n    \"type\": \"execute\",\n    \"result\": StmtResult,\n}\n```\n\nThe `execute` request has the same semantics as the `execute` request in Hrana\nover WebSocket.\n\n['This request was introduced in Hrana 2.']",
            "Execute a batch": "```\ntype BatchStreamReq = {\n    \"type\": \"batch\",\n    \"batch\": Batch,\n}\n\ntype BatchStreamResp = {\n    \"type\": \"batch\",\n    \"result\": BatchResult,\n}\n```\n\nThe `batch` request has the same semantics as the `batch` request in Hrana over\nWebSocket.\n\n['This request was introduced in Hrana 2.']",
            "Execute a sequence of SQL statements": "```\ntype SequenceStreamReq = {\n    \"type\": \"sequence\",\n    \"sql\"?: string | null,\n    \"sql_id\"?: int32 | null,\n}\n\ntype SequenceStreamResp = {\n    \"type\": \"sequence\",\n}\n```\n\nThe `sequence` request has the same semantics as the `sequence` request in\nHrana over WebSocket.\n\n['This request was introduced in Hrana 2.']",
            "Describe a statement": "```\ntype DescribeStreamReq = {\n    \"type\": \"describe\",\n    \"sql\"?: string | null,\n    \"sql_id\"?: int32 | null,\n}\n\ntype DescribeStreamResp = {\n    \"type\": \"describe\",\n    \"result\": DescribeResult,\n}\n```\n\nThe `describe` request has the same semantics as the `describe` request in\nHrana over WebSocket.\n\n['This request was introduced in Hrana 2.']",
            "Store an SQL text on the server": "```\ntype StoreSqlStreamReq = {\n    \"type\": \"store_sql\",\n    \"sql_id\": int32,\n    \"sql\": string,\n}\n\ntype StoreSqlStreamResp = {\n    \"type\": \"store_sql\",\n}\n```\n\nThe `store_sql` request has the same semantics as the `store_sql` request in\nHrana over WebSocket, except that the scope of the SQL texts is just a single\nstream (with WebSocket, it is the whole connection).\n\n['This request was introduced in Hrana 2.']",
            "Close a stored SQL text": "```\ntype CloseSqlStreamReq = {\n    \"type\": \"close_sql\",\n    \"sql_id\": int32,\n}\n\ntype CloseSqlStreamResp = {\n    \"type\": \"close_sql\",\n}\n```\n\nThe `close_sql` request has the same semantics as the `close_sql` request in\nHrana over WebSocket, except that the scope of the SQL texts is just a single\nstream.\n\n['This request was introduced in Hrana 2.']",
            "Get the autocommit state": "```\ntype GetAutocommitStreamReq = {\n    \"type\": \"get_autocommit\",\n}\n\ntype GetAutocommitStreamResp = {\n    \"type\": \"get_autocommit\",\n    \"is_autocommit\": bool,\n}\n```\n\nThe `get_autocommit` request has the same semantics as the `get_autocommit`\nrequest in Hrana over WebSocket.\n\n['This request was introduced in Hrana 3.']"
          },
          "Errors": "If the client receives an HTTP error (4xx or 5xx response), it means that the\nserver encountered an internal error and the stream is no longer valid. The\nclient should attempt to parse the response body as an `Error` structure (using\nthe encoding indicated by the `Content-Type` response header), but the client\nmust be able to handle responses with different bodies, such as plaintext or\nHTML, which might be returned by various components in the HTTP stack."
        },
        "Shared structures": {
          "Errors": "```\ntype Error = {\n    \"message\": string,\n    \"code\"?: string | null,\n}\n```\n\nErrors can be returned by the server in many places in the protocol, and they\nare always represented with the `Error` structure. The `message` field contains\nan English human-readable description of the error. The `code` contains a\nmachine-readable error code.\n\nAt this moment, the error codes are not yet stabilized and depend on the server\nimplementation.\n\n['This structure was introduced in Hrana 1.']",
          "Statements": "```\ntype Stmt = {\n    \"sql\"?: string | null,\n    \"sql_id\"?: int32 | null,\n    \"args\"?: Array<Value>,\n    \"named_args\"?: Array<NamedArg>,\n    \"want_rows\"?: boolean,\n}\n\ntype NamedArg = {\n    \"name\": string,\n    \"value\": Value,\n}\n```\n\nA SQL statement is represented by the `Stmt` structure. The text of the SQL\nstatement is specified either by passing a string directly in the `sql` field,\nor by passing SQL text id that has previously been stored with the `store_sql`\nrequest. Exactly one of `sql` and `sql_id` must be passed.\n\nThe arguments in `args` are bound to parameters in the SQL statement by\nposition. The arguments in `named_args` are bound to parameters by name.\n\nIn SQLite, the names of arguments include the prefix sign (`:`, `@` or `$`). If\nthe name of the argument does not start with this prefix, the server will try to\nguess the correct prefix. If an argument is specified both as a positional\nargument and as a named argument, the named argument should take precedence.\n\nIt is an error if the request specifies an argument that is not expected by the\nSQL statement, or if the request does not specify an argument that is expected\nby the SQL statement. Some servers may not support specifying both positional\nand named arguments.\n\nThe `want_rows` field specifies whether the client is interested in the rows\nproduced by the SQL statement. If it is set to `false`, the server should always\nreply with no rows, even if the statement produced some. If the field is\nomitted, the default value is `true`.\n\nThe SQL text should contain just a single statement. Issuing multiple statements\nseparated by a semicolon is not supported.\n\n['This structure was introduced in Hrana 1. In Hrana 2, the `sql_id` field was\\nadded and the `sql` and `want_rows` fields were made optional.']",
          "Statement results": "```\ntype StmtResult = {\n    \"cols\": Array<Col>,\n    \"rows\": Array<Array<Value>>,\n    \"affected_row_count\": uint64,\n    \"last_insert_rowid\": string | null,\n    \"rows_read\": uint64,\n    \"rows_written\": uint64,\n    \"query_duration_ms\": double,\n}\n\ntype Col = {\n    \"name\": string | null,\n    \"decltype\": string | null,\n}\n```\n\nThe result of executing an SQL statement is represented by the `StmtResult`\nstructure and it contains information about the returned columns in `cols` and\nthe returned rows in `rows` (the array is empty if the statement did not produce\nany rows or if `want_rows` was `false` in the request).\n\n`affected_row_count` counts the number of rows that were changed by the\nstatement. This is meaningful only if the statement was an INSERT, UPDATE or\nDELETE, and the value is otherwise undefined.\n\n`last_insert_rowid` is the ROWID of the last successful insert into a rowid\ntable. The rowid value is a 64-bit signed integer encoded as a string in JSON.\nFor other statements, the value is undefined.\n\n['This structure was introduced in Hrana 1. The `decltype` field in the `Col`\\nstructure was added in Hrana 2.']",
          "Batches": {
            "Conditions": "```\ntype BatchCond =\n    | { \"type\": \"ok\", \"step\": uint32 }\n    | { \"type\": \"error\", \"step\": uint32 }\n    | { \"type\": \"not\", \"cond\": BatchCond }\n    | { \"type\": \"and\", \"conds\": Array<BatchCond> }\n    | { \"type\": \"or\", \"conds\": Array<BatchCond> }\n    | { \"type\": \"is_autocommit\" }\n```\n\nConditions are expressions that evaluate to true or false:\n\n['`ok` evaluates to true if the `step` (referenced by its 0-based index) was\\nexecuted successfully. If the statement was skipped, this condition evaluates to\\nfalse.', '`error` evaluates to true if the `step` (referenced by its 0-based index) has\\nproduced an error. If the statement was skipped, this condition evaluates to\\nfalse.', '`not` evaluates `cond` and returns the logical negative.', '`and` evaluates `conds` and returns the logical conjunction of them.', '`or` evaluates `conds` and returns the logical disjunction of them.', '`is_autocommit` evaluates to true if the stream is currently in the autocommit\\nstate (not inside an explicit transaction)']\n\n['This structure was introduced in Hrana 1. The `is_autocommit` type was added in Hrana 3.']"
          },
          "Batch results": "```\ntype BatchResult = {\n    \"step_results\": Array<StmtResult | null>,\n    \"step_errors\": Array<Error | null>,\n}\n```\n\nThe result of executing a batch is represented by `BatchResult`. The result\ncontains the results or errors of statements from each step. For the step in\n`steps[i]`, `step_results[i]` contains the result of the statement if the\nstatement was executed and succeeded, and `step_errors[i]` contains the error if\nthe statement was executed and failed. If the statement was skipped because its\ncondition evaluated to false, both `step_results[i]` and `step_errors[i]` will\nbe `null`.\n\n['This structure was introduced in Hrana 1.']",
          "Cursor entries": {
            "Step results": "```\ntype StepBeginEntry = {\n    \"type\": \"step_begin\",\n    \"step\": uint32,\n    \"cols\": Array<Col>,\n}\n\ntype StepEndEntry = {\n    \"type\": \"step_end\",\n    \"affected_row_count\": uint32,\n    \"last_insert_rowid\": string | null,\n}\n\ntype RowEntry = {\n    \"type\": \"row\",\n    \"row\": Array<Value>,\n}\n```\n\nAt the beginning of every batch step that is executed, the server produces a\n`step_begin` entry. This entry specifies the index of the step (which refers to\nthe `steps` array in the `Batch` structure). The server sends entries for steps\nin the order in which they are executed. If a step is skipped (because its\ncondition evaluated to false), the server does not send any entry for it.\n\nAfter a `step_begin` entry, the server sends an arbitrary number of `row`\nentries that encode the individual rows produced by the statement, terminated by\nthe `step_end` entry. Together, these entries encode the same information as the\n`StmtResult` structure.\n\nThe server can send another `step_entry` only after the previous step was\nterminated by `step_end` or by `step_error`, described below.",
            "Errors": "```\ntype StepErrorEntry = {\n    \"type\": \"step_error\",\n    \"step\": uint32,\n    \"error\": Error,\n}\n\ntype ErrorEntry = {\n    \"type\": \"error\",\n    \"error\": Error,\n}\n```\n\nThe `step_error` entry indicates that the execution of a statement failed with\nan error. There are two ways in which the server may produce this entry:\n\n['Before a `step_begin` entry was sent: this means that the statement failed\\nvery early, without producing any results. The `step` field indicates which\\nstep has failed (similar to the `step_begin` entry).', 'After a `step_begin` entry was sent: in this case, the server has started\\nexecuting the statement and produced `step_begin` (and perhaps a number of\\n`row` entries), but then encountered an error. The `step` field must in this\\ncase be equal to the `step` of the currently processed step.']\n\nThe `error` entry means that the execution of the whole batch has failed. This\ncan be produced by the server at any time, and it is always the last entry in\nthe cursor."
          },
          "Result of describing a statement": {
            "Parameters": "```\ntype DescribeParam = {\n    \"name\": string | null,\n}\n```\n\nInformation about parameters of the statement is returned in `params`. SQLite\nindexes parameters from 1, so the first object in the `params` array describes\nparameter 1.\n\nFor each parameter, the `name` field specifies the name of the parameter. For\nparameters of the form `?NNN`, `:AAA`, `@AAA` and `$AAA`, the name includes the\ninitial `?`, `:`, `@` or `$` character. Parameters of the form `?` are nameless,\ntheir `name` is `null`.\n\nIt is also possible that some parameters are not referenced in the statement, in\nwhich case the `name` is also `null`.\n\n['This structure was introduced in Hrana 2.']",
            "Columns": "```\ntype DescribeCol = {\n    \"name\": string,\n    \"decltype\": string | null,\n}\n```\n\nInformation about columns of the statement is returned in `cols`.\n\nFor each column, `name` specifies the name assigned by the SQL `AS` clause. For\ncolumns without `AS` clause, the name is not specified.\n\nFor result columns that directly originate from tables in the database,\n`decltype` specifies the declared type of the column. For other columns (such as\nresults of expressions), `decltype` is `null`.\n\n['This structure was introduced in Hrana 2.']"
          },
          "Values": "```\ntype Value =\n    | { \"type\": \"null\" }\n    | { \"type\": \"integer\", \"value\": string }\n    | { \"type\": \"float\", \"value\": number }\n    | { \"type\": \"text\", \"value\": string }\n    | { \"type\": \"blob\", \"base64\": string }\n```\n\nSQLite values are represented by the `Value` structure. The type of the value\ndepends on the `type` field:\n\n['`null`: the SQL NULL value.', '`integer`: a 64-bit signed integer. In JSON, the `value` is a string to avoid\\nlosing precision, because some JSON implementations treat all numbers as\\n64-bit floats.', '`float`: a 64-bit float.', '`text`: a UTF-8 string.', '`blob`: a binary blob with. In JSON, the value is base64-encoded.']\n\n['This structure was introduced in Hrana 1.']"
        },
        "Protobuf schema": {
          "Hrana over WebSocket": "```\nsyntax = \"proto3\";\npackage hrana.ws;\n\nmessage ClientMsg {\n  oneof msg {\n    HelloMsg hello = 1;\n    RequestMsg request = 2;\n  }\n}\n\nmessage ServerMsg {\n  oneof msg {\n    HelloOkMsg hello_ok = 1;\n    HelloErrorMsg hello_error = 2;\n    ResponseOkMsg response_ok = 3;\n    ResponseErrorMsg response_error = 4;\n  }\n}\n\nmessage HelloMsg {\n  optional string jwt = 1;\n}\n\nmessage HelloOkMsg {\n}\n\nmessage HelloErrorMsg {\n  Error error = 1;\n}\n\nmessage RequestMsg {\n  int32 request_id = 1;\n  oneof request {\n    OpenStreamReq open_stream = 2;\n    CloseStreamReq close_stream = 3;\n    ExecuteReq execute = 4;\n    BatchReq batch = 5;\n    OpenCursorReq open_cursor = 6;\n    CloseCursorReq close_cursor = 7;\n    FetchCursorReq fetch_cursor = 8;\n    SequenceReq sequence = 9;\n    DescribeReq describe = 10;\n    StoreSqlReq store_sql = 11;\n    CloseSqlReq close_sql = 12;\n    GetAutocommitReq get_autocommit = 13;\n  }\n}\n\nmessage ResponseOkMsg {\n  int32 request_id = 1;\n  oneof response {\n    OpenStreamResp open_stream = 2;\n    CloseStreamResp close_stream = 3;\n    ExecuteResp execute = 4;\n    BatchResp batch = 5;\n    OpenCursorResp open_cursor = 6;\n    CloseCursorResp close_cursor = 7;\n    FetchCursorResp fetch_cursor = 8;\n    SequenceResp sequence = 9;\n    DescribeResp describe = 10;\n    StoreSqlResp store_sql = 11;\n    CloseSqlResp close_sql = 12;\n    GetAutocommitResp get_autocommit = 13;\n  }\n}\n\nmessage ResponseErrorMsg {\n  int32 request_id = 1;\n  Error error = 2;\n}\n\nmessage OpenStreamReq {\n  int32 stream_id = 1;\n}\n\nmessage OpenStreamResp {\n}\n\nmessage CloseStreamReq {\n  int32 stream_id = 1;\n}\n\nmessage CloseStreamResp {\n}\n\nmessage ExecuteReq {\n  int32 stream_id = 1;\n  Stmt stmt = 2;\n}\n\nmessage ExecuteResp {\n  StmtResult result = 1;\n}\n\nmessage BatchReq {\n  int32 stream_id = 1;\n  Batch batch = 2;\n}\n\nmessage BatchResp {\n  BatchResult result = 1;\n}\n\nmessage OpenCursorReq {\n  int32 stream_id = 1;\n  int32 cursor_id = 2;\n  Batch batch = 3;\n}\n\nmessage OpenCursorResp {\n}\n\nmessage CloseCursorReq {\n  int32 cursor_id = 1;\n}\n\nmessage CloseCursorResp {\n}\n\nmessage FetchCursorReq {\n  int32 cursor_id = 1;\n  uint32 max_count = 2;\n}\n\nmessage FetchCursorResp {\n  repeated CursorEntry entries = 1;\n  bool done = 2;\n}\n\nmessage StoreSqlReq {\n  int32 sql_id = 1;\n  string sql = 2;\n}\n\nmessage StoreSqlResp {\n}\n\nmessage CloseSqlReq {\n  int32 sql_id = 1;\n}\n\nmessage CloseSqlResp {\n}\n\nmessage SequenceReq {\n  int32 stream_id = 1;\n  optional string sql = 2;\n  optional int32 sql_id = 3;\n}\n\nmessage SequenceResp {\n}\n\nmessage DescribeReq {\n  int32 stream_id = 1;\n  optional string sql = 2;\n  optional int32 sql_id = 3;\n}\n\nmessage DescribeResp {\n  DescribeResult result = 1;\n}\n\nmessage GetAutocommitReq {\n  int32 stream_id = 1;\n}\n\nmessage GetAutocommitResp {\n  bool is_autocommit = 1;\n}\n```",
          "Hrana over HTTP": "```\nsyntax = \"proto3\";\npackage hrana.http;\n\nmessage PipelineReqBody {\n  optional string baton = 1;\n  repeated StreamRequest requests = 2;\n}\n\nmessage PipelineRespBody {\n  optional string baton = 1;\n  optional string base_url = 2;\n  repeated StreamResult results = 3;\n}\n\nmessage StreamResult {\n  oneof result {\n    StreamResponse ok = 1;\n    Error error = 2;\n  }\n}\n\nmessage CursorReqBody {\n  optional string baton = 1;\n  Batch batch = 2;\n}\n\nmessage CursorRespBody {\n  optional string baton = 1;\n  optional string base_url = 2;\n}\n\nmessage StreamRequest {\n  oneof request {\n    CloseStreamReq close = 1;\n    ExecuteStreamReq execute = 2;\n    BatchStreamReq batch = 3;\n    SequenceStreamReq sequence = 4;\n    DescribeStreamReq describe = 5;\n    StoreSqlStreamReq store_sql = 6;\n    CloseSqlStreamReq close_sql = 7;\n    GetAutocommitStreamReq get_autocommit = 8;\n  }\n}\n\nmessage StreamResponse {\n  oneof response {\n    CloseStreamResp close = 1;\n    ExecuteStreamResp execute = 2;\n    BatchStreamResp batch = 3;\n    SequenceStreamResp sequence = 4;\n    DescribeStreamResp describe = 5;\n    StoreSqlStreamResp store_sql = 6;\n    CloseSqlStreamResp close_sql = 7;\n    GetAutocommitStreamResp get_autocommit = 8;\n  }\n}\n\nmessage CloseStreamReq {\n}\n\nmessage CloseStreamResp {\n}\n\nmessage ExecuteStreamReq {\n  Stmt stmt = 1;\n}\n\nmessage ExecuteStreamResp {\n  StmtResult result = 1;\n}\n\nmessage BatchStreamReq {\n  Batch batch = 1;\n}\n\nmessage BatchStreamResp {\n  BatchResult result = 1;\n}\n\nmessage SequenceStreamReq {\n  optional string sql = 1;\n  optional int32 sql_id = 2;\n}\n\nmessage SequenceStreamResp {\n}\n\nmessage DescribeStreamReq {\n  optional string sql = 1;\n  optional int32 sql_id = 2;\n}\n\nmessage DescribeStreamResp {\n  DescribeResult result = 1;\n}\n\nmessage StoreSqlStreamReq {\n  int32 sql_id = 1;\n  string sql = 2;\n}\n\nmessage StoreSqlStreamResp {\n}\n\nmessage CloseSqlStreamReq {\n  int32 sql_id = 1;\n}\n\nmessage CloseSqlStreamResp {\n}\n\nmessage GetAutocommitStreamReq {\n}\n\nmessage GetAutocommitStreamResp {\n  bool is_autocommit = 1;\n}\n```",
          "Shared structures": "```\nsyntax = \"proto3\";\npackage hrana;\n\nmessage Error {\n  string message = 1;\n  optional string code = 2;\n}\n\nmessage Stmt {\n  optional string sql = 1;\n  optional int32 sql_id = 2;\n  repeated Value args = 3;\n  repeated NamedArg named_args = 4;\n  optional bool want_rows = 5;\n}\n\nmessage NamedArg {\n  string name = 1;\n  Value value = 2;\n}\n\nmessage StmtResult {\n  repeated Col cols = 1;\n  repeated Row rows = 2;\n  uint64 affected_row_count = 3;\n  optional sint64 last_insert_rowid = 4;\n}\n\nmessage Col {\n  optional string name = 1;\n  optional string decltype = 2;\n}\n\nmessage Row {\n  repeated Value values = 1;\n}\n\nmessage Batch {\n  repeated BatchStep steps = 1;\n}\n\nmessage BatchStep {\n  optional BatchCond condition = 1;\n  Stmt stmt = 2;\n}\n\nmessage BatchCond {\n  oneof cond {\n    uint32 step_ok = 1;\n    uint32 step_error = 2;\n    BatchCond not = 3;\n    CondList and = 4;\n    CondList or = 5;\n    IsAutocommit is_autocommit = 6;\n  }\n\n  message CondList {\n    repeated BatchCond conds = 1;\n  }\n\n  message IsAutocommit {\n  }\n}\n\nmessage BatchResult {\n  map<uint32, StmtResult> step_results = 1;\n  map<uint32, Error> step_errors = 2;\n}\n\nmessage CursorEntry {\n  oneof entry {\n    StepBeginEntry step_begin = 1;\n    StepEndEntry step_end = 2;\n    StepErrorEntry step_error = 3;\n    Row row = 4;\n    Error error = 5;\n  }\n}\n\nmessage StepBeginEntry {\n  uint32 step = 1;\n  repeated Col cols = 2;\n}\n\nmessage StepEndEntry {\n  uint64 affected_row_count = 1;\n  optional sint64 last_insert_rowid = 2;\n}\n\nmessage StepErrorEntry {\n  uint32 step = 1;\n  Error error = 2;\n}\n\nmessage DescribeResult {\n  repeated DescribeParam params = 1;\n  repeated DescribeCol cols = 2;\n  bool is_explain = 3;\n  bool is_readonly = 4;\n}\n\nmessage DescribeParam {\n  optional string name = 1;\n}\n\nmessage DescribeCol {\n  string name = 1;\n  optional string decltype = 2;\n}\n\nmessage Value {\n  oneof value {\n    Null null = 1;\n    sint64 integer = 2;\n    double float = 3;\n    string text = 4;\n    bytes blob = 5;\n  }\n\n  message Null {}\n}\n```"
        }
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 7]"
    },
    {
      "title": "The sqld HTTP API v1 specification (\"Hrana over HTTP\")",
      "description": null,
      "content": {
        "Overview": "This HTTP API uses data structures and semantics from the Hrana protocol;\nversions of the HTTP API are intended to correspond to versions of the Hrana\nprotocol, so HTTP API v1 corresponds to the `hrana1` version of Hrana.\n\nEndpoints in the HTTP API correspond to requests in Hrana. Each request is\nexecuted as if a fresh Hrana stream was opened for the request.\n\nAll request and response bodies are encoded in JSON, with content type\n`application/json`.",
        "Execute a statement": "```\nPOST /v1/execute\n\n-> {\n    \"stmt\": Stmt,\n}\n\n<- {\n    \"result\": StmtResult,\n}\n```\n\nThe `execute` endpoint receives a statement and returns the result of executing\nthe statement. The `Stmt` and `StmtResult` structures are from the Hrana\nprotocol. The semantics of this endpoint is the same as the `execute` request in\nHrana.",
        "Execute a batch": "```\nPOST /v1/batch\n\n-> {\n    \"batch\": Batch,\n}\n\n<- {\n    \"result\": BatchResult,\n}\n```\n\nThe `batch` endpoint receives a batch and returns the result of executing the\nstatement. The `Batch` and `BatchResult` structures are from the Hrana protocol.\nThe semantics of this endpoint is the same as the `batch` request in Hrana.",
        "Errors": "Successful responses are indicated by a HTTP status code in range [200, 300).\nErrors are indicated with HTTP status codes in range [400, 600), and the error\nresponses should have the format of `Error` from the Hrana protocol. However,\nthe clients should be able to handle error responses that don't correspond to\nthis format; in particular, the server may produce some error responses with the\nerror message as plain text."
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 8]"
    },
    {
      "title": "The sqld HTTP API v2 specification (\"Hrana over HTTP\")",
      "description": null,
      "content": {
        "Overview": "The HTTP API uses data structures and semantics from the Hrana 2 protocol.\n\nIndividual requests on the same stream are tied together by the use of a baton.\nThe server returns a baton in every response to a request on the stream, and the\nclient then needs to include the baton in the subsequent request. The client\nmust serialize the requests: it must wait for a response to the previous request\nbefore sending next request.\n\nThe server can also optionally specify a different URL that the client should\nuse for the requests on the stream. This can be used to ensure that stream\nrequests are \"sticky\" and reach the same server.\n\nThe server will close streams after a short period of inactivity, to make sure\nthat abandoned streams don't accumulate on the server.",
        "Check support for version 2": "```\nGET /v2\n```\n\nIf the server supports this version of the HTTP API, it should return a 2xx\nresponse for a GET request on `/v2`. This can be used as a crude version\nnegotiation mechanism by the client.",
        "Execute requests on a stream": "```\nPOST /v2/pipeline\n\n-> {\n    \"baton\": string | null,\n    \"requests\": Array<StreamRequest>,\n}\n\n<- {\n    \"baton\": string | null,\n    \"base_url\": string | null,\n    \"results\": Array<StreamResult>\n}\n\ntype StreamResult =\n    | StreamResultOk\n    | StreamResultError\n\ntype StreamResultOk = {\n    \"type\": \"ok\",\n    \"response\": StreamResponse,\n}\n\ntype StreamResultError = {\n    \"type\": \"error\",\n    \"error\": Error,\n}\n```\n\nThe `pipeline` endpoint is used to execute a pipeline of requests on a stream.\n`baton` in the request specifies the stream. If the client sets `baton` to\n`null`, the server should create a new stream.\n\nServer responds with another `baton` value in the response. If the `baton` value\nin the response is `null`, it means that the server has closed the stream. The\nclient must use this value to refer to this stream in the next request (the\n`baton` in the response should be different from the `baton` in the request).\nThis forces the client to issue the requests serially: it must wait for the\nresponse from a previous `pipeline` request before issuing another request on\nthe same stream.\n\nThe server should ensure that the `baton` values are unpredictable and\nunforgeable, for example by cryptographically signing them.\n\nIf the `base_url` in the response is not `null`, the client should use this URL\nwhen sending further requests on this stream. If it is `null`, the client should\nuse the same URL that it has used for the previous request. The `base_url`\nmust be an absolute URL with \"http\" or \"https\" scheme.\n\nThe `requests` array in the request specifies a sequence of stream requests that\nshould be executed on the stream. The server executes them in order and returns\nthe results in the `results` array in the response. Result is either a success\n(`type` set to `\"ok\"`) or an error (`type` set to `\"error\"`). The server always\nexecutes all requests, even if some of them return errors.\n\nIf the client receives an HTTP error (4xx or 5xx response) in response to the\n`pipeline` endpoint, it means that the server encountered an internal error and\nthe stream is no longer valid.",
        "Requests": {
          "Close stream": "```\ntype CloseStreamReq = {\n    \"type\": \"close\",\n}\n\ntype CloseStreamResp = {\n    \"type\": \"close\",\n}\n```\n\nThe `close` request closes the stream. It is an error if the client tries to\nexecute more requests on the same stream.",
          "Execute a statement": "```\ntype ExecuteStreamReq = {\n    \"type\": \"execute\",\n    \"stmt\": Stmt,\n}\n\ntype ExecuteStreamResp = {\n    \"type\": \"execute\",\n    \"result\": StmtResult,\n}\n```\n\nThe `execute` request has the same semantics as the `execute` request in Hrana.",
          "Execute a batch": "```\ntype BatchStreamReq = {\n    \"type\": \"batch\",\n    \"batch\": Batch,\n}\n\ntype BatchStreamResp = {\n    \"type\": \"batch\",\n    \"result\": BatchResult,\n}\n```\n\nThe `batch` request has the same semantics as the `batch` request in Hrana.",
          "Execute a sequence of SQL statements": "```\ntype SequenceStreamReq = {\n    \"type\": \"sequence\",\n    \"sql\"?: string | null,\n    \"sql_id\"?: int32 | null,\n}\n\ntype SequenceStreamResp = {\n    \"type\": \"sequence\",\n}\n```\n\nThe `sequence` request has the same semantics as the `sequence` request in\nHrana.",
          "Describe a statement": "```\ntype DescribeStreamReq = {\n    \"type\": \"describe\",\n    \"sql\"?: string | null,\n    \"sql_id\"?: int32 | null,\n}\n\ntype DescribeStreamResp = {\n    \"type\": \"describe\",\n    \"result\": DescribeResult,\n}\n```\n\nThe `describe` request has the same semantics as the `describe` request in\nHrana.",
          "Store an SQL text on the server": "```\ntype StoreSqlStreamReq = {\n    \"type\": \"store_sql\",\n    \"sql_id\": int32,\n    \"sql\": string,\n}\n\ntype StoreSqlStreamResp = {\n    \"type\": \"store_sql\",\n}\n```\n\nThe `store_sql` request has the same semantics as the `store_sql` request in\nHrana, except that the scope of the SQL texts is just a single stream (in Hrana,\nit is the whole connection).",
          "Close a stored SQL text": "```\ntype CloseSqlStreamReq = {\n    \"type\": \"close_sql\",\n    \"sql_id\": int32,\n}\n\ntype CloseSqlStreamResp = {\n    \"type\": \"close_sql\",\n}\n```\n\nThe `close_sql` request has the same semantics as the `close_sql` request in\nHrana, except that the scope of the SQL texts is just a single stream."
        }
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 9]"
    },
    {
      "title": "`sqld` User Guide",
      "description": null,
      "content": {
        "Table of Contents": [
          "[`sqld` User Guide](#sqld-user-guide)",
          [
            "[Table of Contents](#table-of-contents)",
            "[Overview](#overview)",
            "[Replication](#replication)",
            [
              "[TLS configuration](#tls-configuration)",
              "[Launching a primary server](#launching-a-primary-server)",
              "[Launching a replica server](#launching-a-replica-server)"
            ],
            "[Client Authentication](#client-authentication)",
            "[Deployment](#deployment)",
            [
              "[Deploying with Docker](#deploying-with-docker)",
              "[Deploying on Fly](#deploying-on-fly)"
            ],
            "[Incremental snapshots](#incremental-snapshots)",
            "[Multitenancy](#multitenancy)",
            [
              "[Path based routing](#path-based-routing)",
              "[Wildcard domain for development](#wildcard-domain-for-development)"
            ]
          ]
        ],
        "Overview": "The `sqld` program provides libsql over HTTP and supports transparent replication.\n\n![libsql cluster overview.](sqld-overview.png)\n\n<p align=\"center\">\nFigure 1. Overview of libsql clustering.\n</p>\n\nFigure 1 shows an overview of libsql cluster where clients execute SQL remotely over HTTP against `sqld` instances.\nIn the middle, there is the _primary_ instance, which is responsible for accepting writes and servicing replicas for write-ahead log (WAL) updates.\nIf a client performs a write operation such as `INSERT` statement in SQL, replicas delegate the write to a primary node.\nRead operations, such as `SELECT` statements, however, are executed on the replica directly.\nThe replicas poll the primary instance for WAL updates periodically over a gRPC connection.",
        "Replication": {
          "TLS configuration": "The nodes in a `sqld` cluster communicate over gRPC with TLS. To set up a `sqld` cluster, you need the following TLS configuration:\n\n['Certificate authority (CA) certificate and private key', 'Primary server certificate and private key', 'Replica server certificates and private keys']\n\nIn TLS speak, the primary server is the server and the replica servers are the clients.\n\nFor _development and testing_ purposes, you can generate TLS keys and certificates with:\n\n```\npython scripts/gen_certs.py\n```\n\nThe script generates the following files:\n\n['`ca_cert.pem` -- certificate authority certificate', '`ca_key.pem` -- certificate authority private key', '`server_cert.pem` -- primary server certificate', '`server_key.pem` -- primary server private key', '`client_cert.pem` -- replica server certificate', '`client_key.pem` -- replica server private key']",
          "Launching a primary server": "To start a `sqld` server in primary mode, run:\n\n```\nsqld \\\n  --http-listen-addr 127.0.0.1:8081 \\\n  --grpc-listen-addr 127.0.0.1:5001 \\\n  --grpc-tls \\\n  --grpc-ca-cert-file ca_cert.pem \\\n  --grpc-cert-file server_cert.pem \\\n  --grpc-key-file server_key.pem\n```\n\nYou now have a `sqld` primary server listening to SQL over HTTP at `127.0.0.1:8081` and gRPC with TLS at `127.0.0.1:5001`.",
          "Launching a replica server": "To start a a `sqld` server in replica mode, run:\n\n```\nsqld \\\n  --http-listen-addr 127.0.0.1:8082 \\\n  --primary-grpc-url https://127.0.0.1:5001 \\\n  --primary-grpc-tls \\\n  --primary-grpc-ca-cert-file ca_cert.pem \\\n  --primary-grpc-cert-file client_cert.pem \\\n  --primary-grpc-key-file client_key.pem\n```\n\nYou now have a `sqld` replica server listening to SQL over HTTP at `127.0.0.1:8082`, which is connected to a primary server at `127.0.0.1:5001`.\n\nYou can add more replicas to the cluster by just starting more `sqld` processes. However, it's recommended that you generate a different TLS configuration for every replica.\n\nTo test the cluster, you can, for example, create a table and insert rows in the replica:\n\n```\ncurl -d '{\"statements\": [\"CREATE TABLE IF NOT EXISTS users (username)\", \"INSERT INTO users VALUES (\\\"alice\\\")\"]}' 127.0.0.1:8082\n```\n\nand query the results from the primary:\n\n```\ncurl -d '{\"statements\": [\"SELECT * FROM users\"]}' 127.0.0.1:8081\n```"
        },
        "Client Authentication": "You can configure client authentication by passing the `--auth-jwt-key-file FILENAME` command line option to `sqld`.\nThe key is either a PKCS#8-encoded Ed25519 public key in PEM, or just plain bytes of the Ed25519 public key in URL-safe base64.",
        "Deployment": {
          "Deploying with Docker": "You can pull the official Docker image for `sqld` with\n\n```\ndocker pull ghcr.io/libsql/sqld:main\n```\n\nYou can find more information about the Docker image [here](./DOCKER.md).",
          "Deploying on Fly": "You can use the existing `fly.toml` file from this repository.\n\nJust run\n\n```\nflyctl launch\n```\n\n... then pick a name and respond \"Yes\" when the prompt asks you to deploy.\n\nYou now have `sqld` running on Fly listening for HTTP connections.\n\nGive it a try with this snippet, replacing `$YOUR_APP` with your app name:\n\n```\ncurl -X POST -d '{\"statements\": [\"create table testme(a,b,c)\"]}' $YOUR_APP.fly.dev\ncurl -X POST -d '{\"statements\": [\"insert into testme values(1,2,3)\"]}' $YOUR_APP.fly.dev\ncurl -X POST -d '{\"statements\": [\"select * from testme\"]}' $YOUR_APP.fly.dev\n```\n\n```\n[{\"b\":2,\"a\":1,\"c\":3}]\n```"
        },
        "Incremental snapshots": "The `sqld` generates incremental snapshots of the database file, which you can apply to a local libSQL replica.\nFor example, suppose you have an application that is not always connected over the network and can't rely on the `sqld` gRPC replication method. In that case, you can configure `sqld` to notify of generated incremental snapshots, sync the snapshot files to another machine, and apply them.\n\nYou can use the `--snapshot-exec` command line option to specify a file, such as a shell script, to execute on snapshot generation. You can also use the `--max-log-duration SECS` command line option\non to control how often `sqld` generates the snapshot files to ensure the freshness of the data on local replicas.\n\nTo use incremental snapshots, first, create a shell script with the name `snapshot.sh`:\n\n```\n#!/bin/bash\n\nSNAPSHOT_FILE=\"$1\"\nNAMESPACE=\"$2\"\n\necho \"Generated incremental snapshot $SNAPSHOT_FILE for namespace $NAMESPACE\"\n\n# At this point we can ship the snapshot file to wherever we would like but we\n# must delete it from its location on disk or else sqld will panic.\nrm $SNAPSHOT_FILE\n```\n\nand then configure `sqld` to generate an incremental snapshot every 5 seconds and invoke the shell script when `sqld` generates a snapshot:\n\n```\nsqld --snapshot-exec ./snapshot.sh --max-log-duration 5\n```\n\nWhen you write to the `sqld` database, you will eventually see log line such as:\n\n```\n2023-08-11T08:21:04.183564Z  INFO sqld::replication::snapshot: snapshot `e126f594-90f4-45be-9350-bc8a01160de9-0-2.snap` successfully created\nGenerated incremental snapshot data.sqld/dbs/default/snapshots/e126f594-90f4-45be-9350-bc8a01160de9-0-2.snap\n```\n\nThe first line is logging from `sqld` and the second line is `sqld` executing `snapshot.sh` script.\nYou can now, for example, `rsync` the snapshot file to another machine, to apply the changes to a local replica with the `Database::sync_frames()` method of the `libsql` crate:\n\n```\nuse libsql::Database;\nuse libsql_replication::{Frames, TempSnapshot};\n\n#[tokio::main]\nasync fn main() {\n    tracing_subscriber::fmt::init();\n\n    let opts = libsql::Opts::with_sync();\n    let db = Database::open_with_opts(\"test.db\", opts).await.unwrap();\n    let conn = db.connect().unwrap();\n\n    let args = std::env::args().collect::<Vec<String>>();\n    if args.len() < 2 {\n        println!(\"Usage: {} <snapshot path>\", args[0]);\n        return;\n    }\n    let snapshot_path = args.get(1).unwrap();\n    let snapshot = TempSnapshot::from_snapshot_file(snapshot_path.as_ref()).unwrap();\n\n    db.sync_frames(Frames::Snapshot(snapshot)).unwrap();\n\n    let rows = conn\n        .query(\"SELECT * FROM sqlite_master\", ())\n        .unwrap()\n        .unwrap();\n    while let Ok(Some(row)) = rows.next() {\n        println!(\n            \"| {:024} | {:024} | {:024} | {:024} |\",\n            row.get::<&str>(0).unwrap(),\n            row.get::<&str>(1).unwrap(),\n            row.get::<&str>(2).unwrap(),\n            row.get::<&str>(3).unwrap(),\n        );\n    }\n}\n```\n\nWhen applying snapshots the format of the file name gives certain information.\nThe format is `{namespace}:{log_id}:{start_frame_no:020x}-{end_frame_no:020x}.snap` where log_id represents the unique write ahead log and then\nfor each unique log_id there will be snapshots starting at frame `0` up until\nthe end. Snapshots must be applied sequentially for each log_id starting at\nframe 0.",
        "Multitenancy": {
          "Path based routing": "For local development and testing, you can also connect to your databases by specifying the database namespace in the URL path.\n\nYou can access namespace `db1` with the `http://local:8080/dev/db1` URL and `db2` with `http://local:8080/dev/db2`, respectively.",
          "Wildcard domain for development": "If you don't feel like editing `/etc/hosts` each time you want to test a new namespace, you can use any domain\nthat returns `127.0.0.1` for all subdomains. One of such domains is `*.db.sarna.dev`, which you can use to access\nyour local `db1` and `db2` as `http://db1.db.sarna.dev` and `http://db2.db.sarna.dev` respectively."
        }
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 10]"
    },
    {
      "title": "Client Version Metrics",
      "description": null,
      "content": {
        "Client version metrics": "Currently, `sqld` supports clients passing their client version via a\n`x-libsql-client-version` header. The value of this header should follow this\npattern:\n\n['Hrana/Remote clients should be `libsql-remote-<language>-<version>`', 'Embedded replica clients should be `libsql-rpc-<language>-<version>`']\n\n`<language>` should be a reference to the language, for example,\n`rust`/`go`/`js`/`python`.\n\n`<version>` should be a reference to either a semver version or a commit sha\n(first 6 chars of the sha)."
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 11]"
    },
    {
      "title": "SQLD HTTP API",
      "description": null,
      "content": {
        "Usage": {
          "The `Value` type": "The `Value` type represents an SQLite value. It has 4 variants:\n\n['Text: a UTF-8 encoded string', 'Integer: a 64-bit signed integer', 'Real: a 64-bits floating number', 'Blob: some binary data, encoded in base64', 'Null: the null value.']\n\nAll these types map to JSON straightforwardly, except for blobs, that are represented as an object with `{ \"base64\": /* base64 encoded blob */ }`",
          "Response format": "Responses to queries can either succeed or fail. When they succeed a payload specific to the endpoint being called is returned with a HTTP 200 (OK) status code.\n\nIn the case of a failure, a specific `Error` response is returned with the appropriate HTTP status code. The `Error` response has the following structure:\n\n```\ntype Error = {\n    error: string\n}\n```\n\nThe general structure of a response is:\n\n```\ntype Response<T> = T | Error;\n```\n\nWhere `T` is the type of the payload in case of success.",
          "Routes": {
            "Queries": {
              "Body": "The body for the query request has the following format:\n\n```\ntype QueryBody = {\n    statements: Array<Query>\n}\n\ntype Query = string | ParamQuery;\ntype ParamQuery = { q: string, params: undefined | Record<string, Value> | Array<Value> }\n```\n\nQueries are either simple strings or `ParamQuery` that accept parameter bindings. The `statements` arrays can contain a mix of the two types.",
              "Response Format": "On success, a request to `POST /` returns a response with an HTTP 200 code and a JSON body with the following structure:\n\n```\ntype BatchResponse = Array<QueryResult>|Error\n\ntype QueryResult = {\n    results: {\n        columns: Array<string>,\n        rows: Array<Array<Value>>,\n        rows_read: uint64,\n        rows_written: uint64,\n        query_duration_ms: double\n    }\n}\n\n```\n\nEach `QueryResult` entry in the `BatchResponse` array corresponds to a query in the request.\nThe `BatchResponse` is either an `Error` or a set of `QueryResult`s.\n\nThe `Query` can either be a plain query string, such as `SELECT * FROM users` or `INSERT INTO users VALUES (\"adhoc\")`, or objects for queries with bound parameters.",
              "Parameter binding": "Queries with bound parameters come in two types:\n\n['Named bound parameters, where the parameter is referred to by a name and is prefixed with a `:`, a `@` or a `$`. If the query uses named parameters, then the `params` field of the query should be an object mapping parameters to their value.', ['Example: a query with named bound parameters'], '```\\n{\\n    \"q\": \"SELECT * FROM users WHERE name = :name AND age = &age AND height > @height AND address = $address\",\\n    \"params\": {\\n        \":name\": \"adhoc\",\\n        \"age\" : \"18\",\\n        \"@height\" : \"170\",\\n        \"$address\" : \"very nice place\",\\n    }\\n}\\n```', 'The prefix of the parameter does not have to be specified in the `params` field (i.e, `name` instead of `:name`). If a\\nparam `name` is given in `params` it will be bound to `:name`, `$name` and `@name` unless `params` contain a better\\nmatch. `:name` is a better match for `:name` than `name`.\\nOne named parameter can occur in a query multiple times but does not have to be repeated in `params`.', 'Positional query parameters, bound by their position in the parameter list, and prefixed `?`. If the query uses positional parameters, the values should be provided as an array to the `params` field.', ['Example: a query with positional bound parameters'], '```\\n{\\n    \"q\": \"SELECT * FROM users WHERE name = ?\",\\n    \"params\": [\"adhoc\"]\\n}\\n```']"
            },
            "Health": "```\nGET /health\n```\n\nThe health route return an `HTTP 200 (OK)` if the server is up and running.",
            "Version": "```\nGET /version\n```\n\nreturns the server's version."
          }
        }
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 12]"
    }
  ]
}