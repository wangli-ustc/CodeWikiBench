{
  "title": "FluentValidation",
  "description": "Documentation for FluentValidation",
  "content": {},
  "metadata": {
    "type": "root",
    "path": "/home/anhnh/CodeWikiBench/data/FluentValidation/original/docs"
  },
  "subpages": [
    {
      "title": "Other Advanced Features",
      "description": null,
      "content": {
        "PreValidate": "If you need to run specific code every time a validator is invoked, you can do this by overriding the `PreValidate` method. This method takes a `ValidationContext` as well as a `ValidationResult`, which you can use to customise the validation process.\n\nThe method should return `true` if validation should continue, or `false` to immediately abort. Any modifications that you made to the `ValidationResult` will be returned to the user.\n\nNote that this method is called before FluentValidation performs its standard null-check against the model being validated, so you can use this to generate an error if the whole model is null, rather than relying on FluentValidation's standard behaviour in this case (which is to throw an exception):\n\n```\npublic class MyValidator : AbstractValidator<Person> \n{\n  public MyValidator() \n  {\n    RuleFor(x => x.Name).NotNull();\n  }\n\n  protected override bool PreValidate(ValidationContext<Person> context, ValidationResult result) \n  {\n    if (context.InstanceToValidate == null) \n    {\n      result.Errors.Add(new ValidationFailure(\"\", \"Please ensure a model was supplied.\"));\n      return false;\n    }\n    return true;\n  }\n}\n```",
        "Root Context Data": "For advanced users, it's possible to pass arbitrary data into the validation pipeline that can be accessed from within custom property validators. This is particularly useful if you need to make a conditional decision based on arbitrary data not available within the object being validated, as validators are stateless.\n\nThe `RootContextData` property is a `Dictionary<string, object>` available on the `ValidationContext`.:\n\n```\nvar person = new Person();\nvar context = new ValidationContext<Person>(person);\ncontext.RootContextData[\"MyCustomData\"] = \"Test\";\nvar validator = new PersonValidator();\nvalidator.Validate(context);\n```\n\nThe RootContextData can then be accessed inside any custom property validators, as well as calls to `Custom`:\n\n```\nRuleFor(x => x.Surname).Custom((x, context) => \n{\n  if(context.RootContextData.ContainsKey(\"MyCustomData\")) \n  {\n    context.AddFailure(\"My error message\");\n  }\n});\n```",
        "Customizing the Validation Exception": "If you use the `ValidateAndThrow` method to [throw an exception when validation fails](start.html#throwing-exceptions) FluentValidation will internally throw a `ValidationException`. You can customzie this behaviour so a different exception is thrown by overriding the `RaiseValidationException` in your validator. \n\nThis simplistic example wraps the default `ValidationException` in an `ArgumentException` instead:\n\n```\nprotected override void RaiseValidationException(ValidationContext<T> context, ValidationResult result)\n{\n    var ex = new ValidationException(result.Errors);\n    throw new ArgumentException(ex.Message, ex);\n}\n```\n\nThis approach is useful if you always want to throw a specific custom exception type every time `ValidateAndThrow` is invoked.\n\nAs an alternative you could create your own extension method that calls `Validate` and then throws your own custom exception if there are validation errors. \n\n```\npublic static class FluentValidationExtensions\n{\n    public static void ValidateAndThrowArgumentException<T>(this IValidator<T> validator, T instance)\n    {\n        var res = validator.Validate(instance);\n\n        if (!res.IsValid)\n        {\n            var ex = new ValidationException(res.Errors);\n            throw new ArgumentException(ex.Message, ex);\n        }\n    }\n}\n```\n\nThis approach is more useful if you only want to throw the custom exception when your specific method is invoked, rather than any time `ValidateAndThrow` is invoked."
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 0]"
    },
    {
      "title": "ASP.NET Core",
      "description": null,
      "content": {
        "Getting started": "The following examples will make use of a `Person` object which is validated using a `PersonValidator`. These classes are defined as follows:\n\n```\npublic class Person \n{\n  public int Id { get; set; }\n  public string Name { get; set; }\n  public string Email { get; set; }\n  public int Age { get; set; }\n}\n\npublic class PersonValidator : AbstractValidator<Person> \n{\n  public PersonValidator() \n  {\n    RuleFor(x => x.Id).NotNull();\n    RuleFor(x => x.Name).Length(0, 10);\n    RuleFor(x => x.Email).EmailAddress();\n    RuleFor(x => x.Age).InclusiveBetween(18, 60);\n  }\n}\n```\n\nIf you're using MVC, Web Api or Razor Pages you'll need to register your validator with the Service Provider in the `ConfigureServices` method of your application's `Startup` class. (note that if you're using Minimal APIs, [see the section on Minimal APIs below](aspnet.html#minimal-apis)). \n\n```\npublic void ConfigureServices(IServiceCollection services) \n{\n    // If you're using MVC or WebApi you'll probably have\n    // a call to AddMvc() or AddControllers() already.\n    services.AddMvc();\n    \n    // ... other configuration ...\n    \n    services.AddScoped<IValidator<Person>, PersonValidator>();\n}\n```\n\nHere we register our `PersonValidator` with the service provider by calling `AddScoped`.\n\n```\n.. note::\n  Note that you must register each validator as `IValidator<T>` where `T` is the type being validated. So if you have a `PersonValidator` that inherits from `AbstractValidator<Person>` then you should register it as `IValidator<Person>`\n```\n\nAlternatively you can register all validators in a specific assembly by using our Service Collection extensions. To do this you'll need to install the `FluentValidation.DependencyInjectionExtensions` package and then call the appropriate `AddValidators...` extension method on the services collection. [See this page for more details](di.html#automatic-registration)\n\n```\npublic void ConfigureServices(IServiceCollection services) \n{\n    services.AddMvc();\n\n    // ... other configuration ...\n\n    services.AddValidatorsFromAssemblyContaining<PersonValidator>();\n}\n```\n\nHere we use the `AddValidatorsFromAssemblyContaining` method from the `FluentValidation.DependencyInjectionExtension` package to automatically register all validators in the same assembly as `PersonValidator` with the service provider.\n\nNow that the validators are registered with the service provider you can start working with either manual validation or automatic validation.\n\n```\n.. note::\n   The auto-registration method used above uses reflection to scan one or more assemblies for validators. An alternative approach would be to use a source generator such as `AutoRegisterInject <https://github.com/patrickklaeren/AutoRegisterInject>`_ to set up registrations. \n```",
        "Manual Validation": "With the manual validation approach, you'll inject the validator into your controller (or Razor page) and invoke it against the model.\n\nFor example, you might have a controller that looks like this:\n\n```\npublic class PeopleController : Controller \n{\n  private IValidator<Person> _validator;\n  private IPersonRepository _repository;\n\n  public PeopleController(IValidator<Person> validator, IPersonRepository repository) \n  {\n    // Inject our validator and also a DB context for storing our person object.\n    _validator = validator;\n    _repository = repository;\n  }\n\n  public ActionResult Create() \n  {\n    return View();\n  }\n\n  [HttpPost]\n  public async Task<IActionResult> Create(Person person) \n  {\n    ValidationResult result = await _validator.ValidateAsync(person);\n\n    if (!result.IsValid) \n    {\n      // Copy the validation results into ModelState.\n      // ASP.NET uses the ModelState collection to populate \n      // error messages in the View.\n      result.AddToModelState(this.ModelState);\n\n      // re-render the view when validation failed.\n      return View(\"Create\", person);\n    }\n\n    _repository.Save(person); //Save the person to the database, or some other logic\n\n    TempData[\"notice\"] = \"Person successfully created\";\n    return RedirectToAction(\"Index\");\n  }\n}\n```\n\nBecause our validator is registered with the Service Provider, it will be injected into our controller via the constructor. We can then make use of the validator inside the `Create` action by invoking it with `ValidateAsync`. \n\nIf validation fails, we need to pass the error messages back down to the view so they can be displayed to the end user. We can do this by defining an extension method for FluentValidation's `ValidationResult` type that copies the error messages into ASP.NET's `ModelState` dictionary:\n\n```\npublic static class Extensions \n{\n  public static void AddToModelState(this ValidationResult result, ModelStateDictionary modelState) \n  {\n    foreach (var error in result.Errors) \n    {\n      modelState.AddModelError(error.PropertyName, error.ErrorMessage);\n    }\n  }\n}\n```\n\nThis method is invoked inside the controller action in the example above. \n\nFor completeness, here is the corresponding View. This view will pick up the error messages from `ModelState` and display them next to the corresponding property. (If you were writing an API controller, then you'd probably return either a `ValidationProblemDetails` or `BadRequest` instead of a view result)\n\n```\n@model Person\n\n<div asp-validation-summary=\"ModelOnly\"></div>\n\n<form asp-action=\"Create\">\n  Id: <input asp-for=\"Id\" /> <span asp-validation-for=\"Id\"></span>\n  <br />\n  Name: <input asp-for=\"Name\" /> <span asp-validation-for=\"Name\"></span>\n  <br />\n  Email: <input asp-for=\"Email\" /> <span asp-validation-for=\"Email\"></span>\n  <br />\n  Age: <input asp-for=\"Age\" /> <span asp-validation-for=\"Age\"></span>\n\n  <br /><br />\n  <input type=\"submit\" value=\"submit\" />\n</form>\n```",
        "Automatic Validation": {
          "Using the ASP.NET Validation Pipeline": "The `FluentValidation.AspNetCore` package provides auto-validation for ASP.NET Core MVC projects by plugging into ASP.NET's validation pipeline. \n\nWith automatic validation using the validation pipeline, FluentValidation plugs into ASP.NET's bult-in validation process that's part of ASP.NET Core MVC and allows models to be validated before a controller action is invoked (during model-binding). This approach to validation is more seamless but has several downsides:\n\n['**The ASP.NET validation pipeline is not asynchronous**: If your validator contains asynchronous rules then your validator will not be able to run. You will receive an exception at runtime if you attempt to use an asynchronous validator with auto-validation.', '**It is MVC-only**: This approach for auto-validation only works with MVC Controllers and Razor Pages. It does not work with the more modern parts of ASP.NET such as Minimal APIs or Blazor.', \"**It is harder to debug**: The 'magic' nature of auto-validation makes it hard to debug/troubleshoot if something goes wrong as so much is done behind the scenes. \"]\n\n```\n.. warning::\n  We no longer recommend using this approach for new projects but it is still available for legacy implementations.\n```\n\nInstructions for this appraoch can be found in the `FluentValidation.AspNetCore` package [can be found on its project page here](https://github.com/FluentValidation/FluentValidation.AspNetCore#aspnet-core-integration-for-fluentvalidation).",
          "Using a Filter": "An alternative approach for performing automatic validation is to use an Action Filter. This approach works asynchronously which mitigates the synchronous limitation of the Validation Pipeline approach (above). Support for this approach isn't provided out of the box, but you can use the 3rd party [SharpGrip.FluentValidation.AutoValidation](https://github.com/SharpGrip/FluentValidation.AutoValidation) package for this purpose. "
        },
        "Clientside Validation": "FluentValidation is a server-side library and does not provide any client-side validation directly. However, it can provide metadata which can be applied to the generated HTML elements for use with a client-side framework such as jQuery Validate in the same way that ASP.NET's default validation attributes work.\n\nTo make use of this metadata you'll need to install the separate `FluentValidation.AspNetCore` package. Instructions for installing and using this package [can be found on its project page here](https://github.com/FluentValidation/FluentValidation.AspNetCore#aspnet-core-integration-for-fluentvalidation). Note that this package is no longer supported, but is still available to use. \n\nAlternatively, instead of using client-side validation you could instead execute your full server-side rules via AJAX using a library such as [FormHelper](https://github.com/sinanbozkus/FormHelper). This allows you to use the full power of FluentValidation, while still having a responsive user experience.",
        "Minimal APIs": "When using FluentValidation with minimal APIs, you can still register the validators with the service provider, (or you can instantiate them directly if they don't have dependencies) and invoke them inside your API endpoint.\n\n```\nvar builder = WebApplication.CreateBuilder(args);\nvar app = builder.Build();\n\n// Register validator with service provider (or use one of the automatic registration methods)\nbuilder.Services.AddScoped<IValidator<Person>, PersonValidator>();\n\n// Also registering a DB access repository for demo purposes\n// replace this with whatever you're using in your application.\nbuilder.Services.AddScoped<IPersonRepository, PersonRepository>();\n\napp.MapPost(\"/person\", async (IValidator<Person> validator, IPersonRepository repository, Person person) => \n{\n  ValidationResult validationResult = await validator.ValidateAsync(person);\n\n  if (!validationResult.IsValid) \n  {\n    return Results.ValidationProblem(validationResult.ToDictionary());\n  }\n\n  repository.Save(person);\n  return Results.Created($\"/{person.Id}\", person);\n});\n```\n\nNote the `ToDictionary` method on the `ValidationResult` is only available from FluentValidation 11.1 and newer. In older versions you will need to implement this as an extension method:\n\n```\npublic static class FluentValidationExtensions\n{\n  public static IDictionary<string, string[]> ToDictionary(this ValidationResult validationResult)\n    {\n      return validationResult.Errors\n        .GroupBy(x => x.PropertyName)\n        .ToDictionary(\n          g => g.Key,\n          g => g.Select(x => x.ErrorMessage).ToArray()\n        );\n    }\n}\n\n```\n\nAlternatively, instead of manually invoking the validator you could use a filter to apply validation to an endpoint (or group of endpoints). This isn't supported out of the box, but you can use one of the following the third-party package for this purpose:\n\n['[ForEvolve.FluentValidation.AspNetCore.Http](https://github.com/Carl-Hugo/FluentValidation.AspNetCore.Http)', '[SharpGrip.FluentValidation.AutoValidation](https://github.com/SharpGrip/FluentValidation.AutoValidation)']"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 1]"
    },
    {
      "title": "Async",
      "description": null,
      "content": {
        "Asynchronous Validation": "In some situations, you may wish to define asynchronous rules, for example when working with an external API. By default, FluentValidation allows custom rules defined with `MustAsync` or `CustomAsync` to be run asynchronously, as well as defining asynchronous conditions with `WhenAsync`.\n\nA simplistic solution that checks if a user ID is already in use using an external web API:\n\n```\npublic class CustomerValidator : AbstractValidator<Customer> \n{\n  SomeExternalWebApiClient _client;\n\n  public CustomerValidator(SomeExternalWebApiClient client) \n  {\n    _client = client;\n\n    RuleFor(x => x.Id).MustAsync(async (id, cancellation) => \n    {\n      bool exists = await _client.IdExists(id);\n      return !exists;\n    }).WithMessage(\"ID Must be unique\");\n  }\n}\n```\n\nInvoking the validator is essentially the same, but you should now invoke it by calling `ValidateAsync`:\n\n```\nvar validator = new CustomerValidator(new SomeExternalWebApiClient());\nvar result = await validator.ValidateAsync(customer);\n```\n\n```\n.. note::\n  Calling `ValidateAsync` will run both synchronous and asynchronous rules. \n```\n\n```\n.. warning::\n  If your validator contains asynchronous validators or asynchronous conditions, it's important that you *always* call `ValidateAsync` on your validator and never `Validate`. If you call `Validate`, then an exception will be thrown.\n\n  You should not use asynchronous rules when `using automatic validation with ASP.NET <aspnet.html>`_ as ASP.NET's validation pipeline is not asynchronous. If you use asynchronous rules with ASP.NET's automatic validation, they will always be run synchronously (10.x and older) or throw an exception (11.x and newer).\n```"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 2]"
    },
    {
      "title": "Blazor",
      "description": null,
      "content": {
        "Blazor": "FluentValidation does not provide integration with Blazor out of the box, but there are several third party libraries you can use to do this:\n\n['[Blazored.FluentValidation](https://github.com/Blazored/FluentValidation)', '[Blazor-Validation](https://github.com/mrpmorris/blazor-validation)', '[Accelist.FluentValidation.Blazor](https://github.com/ryanelian/FluentValidation.Blazor)', '[vNext.BlazorComponents.FluentValidation](https://github.com/Liero/vNext.BlazorComponents.FluentValidation)']"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 3]"
    },
    {
      "title": "Built-in Validators",
      "description": null,
      "content": {
        "NotNull Validator": "Ensures that the specified property is not null.\n\nExample:\n\n```\nRuleFor(customer => customer.Surname).NotNull();\n```\n\nExample error: *'Surname' must not be empty.*\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']",
        "NotEmpty Validator": "Ensures that the specified property is not null, an empty string or whitespace (or the default value for value types, e.g., 0 for `int`).\nWhen used on an IEnumerable (such as arrays, collections, lists, etc.), the validator ensures that the IEnumerable is not empty.\n\nExample:\n\n```\nRuleFor(customer => customer.Surname).NotEmpty();\n```\n\nExample error: *'Surname' should not be empty.*\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']",
        "NotEqual Validator": "Ensures that the value of the specified property is not equal to a particular value (or not equal to the value of another property).\n\nExample:\n\n```\n//Not equal to a particular value\nRuleFor(customer => customer.Surname).NotEqual(\"Foo\");\n\n//Not equal to another property\nRuleFor(customer => customer.Surname).NotEqual(customer => customer.Forename);\n```\n\nExample error: *'Surname' should not be equal to 'Foo'*\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{ComparisonValue}` – Value that the property should not equal', '`{ComparisonProperty}` – Name of the property being compared against (if any)', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']\n\nOptionally, a comparer can be provided to ensure a specific type of comparison is performed:\n\n```\nRuleFor(customer => customer.Surname).NotEqual(\"Foo\", StringComparer.OrdinalIgnoreCase);\n```\n\nAn ordinal comparison will be used by default. If you wish to do a culture-specific comparison instead, you should pass `StringComparer.CurrentCulture` as the second parameter.",
        "Equal Validator": "Ensures that the value of the specified property is equal to a particular value (or equal to the value of another property).\n\nExample:\n\n```\n//Equal to a particular value\nRuleFor(customer => customer.Surname).Equal(\"Foo\");\n\n//Equal to another property\nRuleFor(customer => customer.Password).Equal(customer => customer.PasswordConfirmation);\n```\n\nExample error: *'Surname' should be equal to 'Foo'*\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{ComparisonValue}` – Value that the property should equal', '`{ComparisonProperty}` – Name of the property being compared against (if any)', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']\n\n```\nRuleFor(customer => customer.Surname).Equal(\"Foo\", StringComparer.OrdinalIgnoreCase);\n```\n\nAn ordinal comparison will be used by default. If you wish to do a culture-specific comparison instead, you should pass `StringComparer.CurrentCulture` as the second parameter.",
        "Length Validator": "Ensures that the length of a particular string property is within the specified range. However, it doesn't ensure that the string property isn't null.\n\nExample:\n\n```\nRuleFor(customer => customer.Surname).Length(1, 250); //must be between 1 and 250 chars (inclusive)\n```\n\nExample error: *'Surname' must be between 1 and 250 characters. You entered 251 characters.*\n\nNote: Only valid on string properties.\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{MinLength}` – Minimum length', '`{MaxLength}` – Maximum length', '`{TotalLength}` – Number of characters entered', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']",
        "MaxLength Validator": "Ensures that the length of a particular string property is no longer than the specified value.\n\nExample:\n\n```\nRuleFor(customer => customer.Surname).MaximumLength(250); //must be 250 chars or fewer\n```\n\nExample error: *The length of 'Surname' must be 250 characters or fewer. You entered 251 characters.*\n\nNote: Only valid on string properties.\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{MaxLength}` – Maximum length', '`{TotalLength}` – Number of characters entered', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']",
        "MinLength Validator": "Ensures that the length of a particular string property is longer than the specified value.\n\nExample:\n\n```\nRuleFor(customer => customer.Surname).MinimumLength(10); //must be 10 chars or more\n```\n\nExample error: *The length of 'Surname' must be at least 10 characters. You entered 5 characters.*\n\nNote: Only valid on string properties.\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{MinLength}` – Minimum length', '`{TotalLength}` – Number of characters entered', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']",
        "Less Than Validator": "Ensures that the value of the specified property is less than a particular value (or less than the value of another property).\n\nExample:\n\n```\n//Less than a particular value\nRuleFor(customer => customer.CreditLimit).LessThan(100);\n\n//Less than another property\nRuleFor(customer => customer.CreditLimit).LessThan(customer => customer.MaxCreditLimit);\n```\n\nExample error: *'Credit Limit' must be less than 100.*\n\nNotes: Only valid on types that implement `IComparable<T>`\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{ComparisonValue}` – Value to which the property was compared', '`{ComparisonProperty}` – Name of the property being compared against (if any)', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']",
        "Less Than Or Equal Validator": "Ensures that the value of the specified property is less than or equal to a particular value (or less than or equal to the value of another property).\n\nExample:\n\n```\n//Less than a particular value\nRuleFor(customer => customer.CreditLimit).LessThanOrEqualTo(100);\n\n//Less than another property\nRuleFor(customer => customer.CreditLimit).LessThanOrEqualTo(customer => customer.MaxCreditLimit);\n```\n\nExample error: *'Credit Limit' must be less than or equal to 100.*\nNotes: Only valid on types that implement `IComparable<T>`\n\n['`{PropertyName}` – Name of the property being validated', '`{ComparisonValue}` – Value to which the property was compared', '`{ComparisonProperty}` – Name of the property being compared against (if any)', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']",
        "Greater Than Validator": "Ensures that the value of the specified property is greater than a particular value (or greater than the value of another property).\n\nExample:\n\n```\n//Greater than a particular value\nRuleFor(customer => customer.CreditLimit).GreaterThan(0);\n\n//Greater than another property\nRuleFor(customer => customer.CreditLimit).GreaterThan(customer => customer.MinimumCreditLimit);\n```\n\nExample error: *'Credit Limit' must be greater than 0.*\nNotes: Only valid on types that implement `IComparable<T>`\n\n['`{PropertyName}` – Name of the property being validated', '`{ComparisonValue}` – Value to which the property was compared', '`{ComparisonProperty}` – Name of the property being compared against (if any)', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']",
        "Greater Than Or Equal Validator": "Ensures that the value of the specified property is greater than or equal to a particular value (or greater than or equal to the value of another property).\n\nExample:\n\n```\n//Greater than a particular value\nRuleFor(customer => customer.CreditLimit).GreaterThanOrEqualTo(1);\n\n//Greater than another property\nRuleFor(customer => customer.CreditLimit).GreaterThanOrEqualTo(customer => customer.MinimumCreditLimit);\n```\n\nExample error: *'Credit Limit' must be greater than or equal to 1.*\nNotes: Only valid on types that implement `IComparable<T>`\n\n['`{PropertyName}` – Name of the property being validated', '`{ComparisonValue}` – Value to which the property was compared', '`{ComparisonProperty}` – Name of the property being compared against (if any)', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']",
        "Predicate Validator": "(Also known as `Must`)\n\nPasses the value of the specified property into a delegate that can perform custom validation logic on the value.\n\nExample:\n\n```\nRuleFor(customer => customer.Surname).Must(surname => surname == \"Foo\");\n```\n\nExample error: *The specified condition was not met for 'Surname'*\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']\n\nNote that there is an additional overload for `Must` that also accepts an instance of the parent object being validated. This can be useful if you want to compare the current property with another property from inside the predicate:\n\n```\nRuleFor(customer => customer.Surname).Must((customer, surname) => surname != customer.Forename)\n```\n\nNote that in this particular example, it would be better to use the cross-property version of `NotEqual`.",
        "Regular Expression Validator": "Ensures that the value of the specified property matches the given regular expression.\n\nExample:\n\n```\nRuleFor(customer => customer.Surname).Matches(\"some regex here\");\n```\n\nExample error: *'Surname' is not in the correct format.*\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{PropertyValue}` – Current value of the property', '`{RegularExpression}` – Regular expression that was not matched', '`{PropertyPath}` - The full path of the property']",
        "Email Validator": "Ensures that the value of the specified property is a valid email address format.\n\nExample:\n\n```\nRuleFor(customer => customer.Email).EmailAddress();\n```\n\nExample error: *'Email' is not a valid email address.*\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']\n\nThe email address validator can work in 2 modes. The default mode just performs a simple check that the string contains an \"@\" sign which is not at the beginning or the end of the string. This is an intentionally naive check to match the behaviour of ASP.NET Core's `EmailAddressAttribute`, which performs the same check. For the reasoning behind this, see [this post](https://github.com/dotnet/corefx/issues/32740):\n\nFrom the comments:\n\n['\"The check is intentionally naive because doing something infallible is very hard. The email really should be validated in some other way, such as through an email confirmation flow where an email is actually sent. The validation attribute is designed only to catch egregiously wrong values such as for a U.I.\"']\n\nAlternatively, you can use the old email validation behaviour that uses a regular expression consistent with the .NET 4.x version of the ASP.NET `EmailAddressAttribute`. You can use this behaviour in FluentValidation by calling `RuleFor(x => x.Email).EmailAddress(EmailValidationMode.Net4xRegex)`. Note that this approach is deprecated and will generate a warning as regex-based email validation is not recommended.\n\n```\n.. note::\n  In FluentValidation 9, the ASP.NET Core-compatible \"simple\" check is the default mode. In FluentValidation 8.x (and older), the Regex mode is the default.\n```",
        "Credit Card Validator": "Checks whether a string property could be a valid credit card number.\n\nExample:\n\n```\nRuleFor(x => x.CreditCard).CreditCard();\n```\n\nExample error: *'Credit Card' is not a valid credit card number.*\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']",
        "Enum Validator": "Checks whether a numeric value is valid to be in that enum. This is used to prevent numeric values from being cast to an enum type when the resulting value would be invalid. For example, the following is possible:\n\n```\npublic enum ErrorLevel \n{\n  Error = 1,\n  Warning = 2,\n  Notice = 3\n}\n\npublic class Model\n{\n  public ErrorLevel ErrorLevel { get; set; }\n}\n\nvar model = new Model();\nmodel.ErrorLevel = (ErrorLevel)4;\n```\n\nThe compiler will allow this, but a value of 4 is technically not valid for this enum. The Enum validator can prevent this from happening.\n\n```\nRuleFor(x => x.ErrorLevel).IsInEnum();\n```\n\nExample error: *'Error Level' has a range of values which does not include '4'.*\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']",
        "Enum Name Validator": "Checks whether a string is a valid enum name.\n\nExample:\n\n```\n// For a case sensitive comparison\nRuleFor(x => x.ErrorLevelName).IsEnumName(typeof(ErrorLevel));\n\n// For a case-insensitive comparison\nRuleFor(x => x.ErrorLevelName).IsEnumName(typeof(ErrorLevel), caseSensitive: false);\n```\n\nExample error: *'Error Level' has a range of values which does not include 'Foo'.*\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']",
        "Empty Validator": "Opposite of the `NotEmpty` validator. Checks if a property value is null, or is the default value for the type.\nWhen used on an IEnumerable (such as arrays, collections, lists, etc.), the validator ensures that the IEnumerable is empty.\n\nExample:\n\n```\nRuleFor(x => x.Surname).Empty();\n```\n\nExample error: *'Surname' must be empty.*\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']",
        "Null Validator": "Opposite of the `NotNull` validator. Checks if a property value is null.\n\nExample:\n\n```\nRuleFor(x => x.Surname).Null();\n```\n\nExample error: *'Surname' must be empty.*\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{PropertyValue}` – Current value of the property', '`{PropertyPath}` - The full path of the property']",
        "ExclusiveBetween Validator": "Checks whether the property value is in a range between the two specified numbers (exclusive).\n\nExample:\n\n```\nRuleFor(x => x.Id).ExclusiveBetween(1,10);\n```\n\nExample error: *'Id' must be between 1 and 10 (exclusive). You entered 1.*\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{PropertyValue}` – Current value of the property', '`{From}` – Lower bound of the range', '`{To}` – Upper bound of the range', '`{PropertyPath}` - The full path of the property']",
        "InclusiveBetween Validator": "Checks whether the property value is in a range between the two specified numbers (inclusive).\n\nExample:\n\n```\nRuleFor(x => x.Id).InclusiveBetween(1,10);\n```\n\nExample error: *'Id' must be between 1 and 10. You entered 0.*\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{PropertyValue}` – Current value of the property', '`{From}` – Lower bound of the range', '`{To}` – Upper bound of the range', '`{PropertyPath}` - The full path of the property']",
        "PrecisionScale Validator": "Checks whether a decimal value has the specified precision and scale.\n\nExample:\n\n```\nRuleFor(x => x.Amount).PrecisionScale(4, 2, false);\n```\n\nExample error: *'Amount' must not be more than 4 digits in total, with allowance for 2 decimals. 5 digits and 3 decimals were found.*\n\nString format args:\n\n['`{PropertyName}` – Name of the property being validated', '`{PropertyValue}` – Current value of the property', '`{ExpectedPrecision}` – Expected precision', '`{ExpectedScale}` – Expected scale', '`{Digits}` – Total number of digits in the property value', '`{ActualScale}` – Actual scale of the property value', '`{PropertyPath}` - The full path of the property']\n\nNote that the 3rd parameter of this method is `ignoreTrailingZeros`. When set to `true`, trailing zeros after the decimal point will not count towards the expected number of decimal places. \n\nExample:\n\n['When `ignoreTrailingZeros` is `false` then the decimal `123.4500` will be considered to have a precision of 7 and scale of 4', 'When `ignoreTrailingZeros` is `true` then the decimal `123.4500` will be considered to have a precision of 5 and scale of 2. ']\n\nPlease also note that this method implies certain range of values that will be accepted. For example in case of `.PrecisionScale(3, 1)`, the method will accept values between `-99.9` and `99.9`, inclusive. Which means that integer part is always controlled to contain at most `3 - 1` digits, independently from `ignoreTrailingZeros` parameter.\n\nNote that prior to FluentValidation 11.4, this method was called `ScalePrecision` instead and had its parameters reversed. For more details [see this GitHub issue](https://github.com/FluentValidation/FluentValidation/issues/2030)"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 4]"
    },
    {
      "title": "Setting the Cascade mode",
      "description": null,
      "content": {
        "Rule-Level Cascade Modes": "Imagine you have two validators defined as part of a single rule definition, a `NotNull` validator and a `NotEqual` validator:\n\n```\npublic class PersonValidator : AbstractValidator<Person> {\n  public PersonValidator() {\n    RuleFor(x => x.Surname).NotNull().NotEqual(\"foo\");\n  }\n}\n```\n\nThis will first check whether the Surname property is not null and then will check if it's not equal to the string \"foo\". If the first validator (`NotNull`) fails, then by default, the call to `NotEqual` will still be invoked. This can be changed for this specific rule only by specifying a cascade mode of `Stop` (omitting the class and constructor definition from now on; assume that they are still present as above):\n\n```\nRuleFor(x => x.Surname).Cascade(CascadeMode.Stop).NotNull().NotEqual(\"foo\");\n```\n\nNow, if the `NotNull` validator fails then the `NotEqual` validator will not be executed. This is particularly useful if you have a complex chain where each validator depends on the previous validator to succeed.\n\nThe two cascade modes are:\n\n['`Continue` (the default) - always invokes all rules in a validator class, or all validators in a rule, depending on where it is used (see below).', '`Stop` - stops executing a validator class as soon as a rule fails, or stops executing a rule as soon as a validator fails, depending on where it is used (see below).']\n\nIf you have a validator class with multiple rules, and would like this `Stop` behaviour to be set for all of your rules, you could do e.g.:\n\n```\nRuleFor(x => x.Forename).Cascade(CascadeMode.Stop).NotNull().NotEqual(\"foo\");\nRuleFor(x => x.MiddleNames).Cascade(CascadeMode.Stop).NotNull().NotEqual(\"foo\");\nRuleFor(x => x.Surname).Cascade(CascadeMode.Stop).NotNull().NotEqual(\"foo\");\n```\n\nTo avoid repeating `Cascade(CascadeMode.Stop)`, you can set a default value for the rule-level cascade mode by setting the `AbstractValidator.RuleLevelCascadeMode` property, resulting in\n\n```\nRuleLevelCascadeMode = CascadeMode.Stop;\n\nRuleFor(x => x.Forename).NotNull().NotEqual(\"foo\");\nRuleFor(x => x.MiddleNames).NotNull().NotEqual(\"foo\");\nRuleFor(x => x.Surname).NotNull().NotEqual(\"foo\");\n```\n\nWith default global settings, this code will stop executing any rule whose `NotNull` call fails, and not call `NotEqual`, but it will then continue to the next rule, and always execute all three, regardless of failures. See \"Validator Class-Level Cascade Modes\" for how to control this behavior. This particular behaviour is useful if you want to create a list of all validation failures, as opposed to only returning the first one.\n\nSee \"Global Default Cascade Modes\" for setting the default value of this property.",
        "Validator Class-Level Cascade Modes": "As well as being set at the rule level, the cascade mode can also be set at validator class-level, using the property `AbstractValidator.ClassLevelCascadeMode`. This controls the cascade behaviour _in between_ rules within that validator, but does not affect the rule-level cascade behaviour described above.\n\nFor example, the code above will execute all three rules, even if any of them fail. To stop execution of the validator class completely if any rule fails, you can set `AbstractValidator.ClassLevelCascadeMode` to `Stop`. This will result in complete \"fail fast\" behavior, and return only return a maximum of one error.\n\nSee \"Global Default Cascade Modes\" for setting the default value of this property.",
        "Global Default Cascade Modes": "To set the default cascade modes at rule-level and/or validator class-level globally, set `ValidatorOptions.Global.DefaultRuleLevelCascadeMode` and/or `ValidatorOptions.Global.DefaultClassLevelCascadeMode` during your application's startup routine. Both of these default to `Continue`.\n\n```\n.. warning::\n  The RuleLevelCascadeMode, ClassLevelCascadeMode, and their global defaults are only available in FluentValidation 11 and newer.\n```",
        "Introduction of RuleLevelCascadeMode and ClassLevelCascadeMode (and removal of CascadeMode)": "The `AbstractValidator.RuleLevelCascadeMode`, `AbstractValidator.ClassLevelCascadeMode`, and their global defaults were introduced in FluentValidation 11\n\nIn older versions, there was only one property controlling cascade modes: `AbstractValidator.CascadeMode`. Changing this value would set the cascade mode at both validator class-level and rule-level. Therefore, for example, if you wanted to have the above-described functionality where you create a list of validation errors, by stopping on failure at rule-level to avoid crashes, but continuing at validator class-level, you would need to set `AbstractValidator.CascadeMode` to `Continue`, and then repeat `Cascade(CascadeMode.Stop)` on every rule chain.\n\nThe new properties enable finer control of the cascade mode at the different levels, with less repetition.\n\n```\n.. warning::\n  The `CascadeMode` property was deprecated in FluentValidation 11 and removed in FluentValidation 12. The `RuleLevelCascadeMode` and `ClassLevelCascadeMode` properties should be used instead.\n  \n  To convert to the new properties, see `the upgrade guide <upgrading-to-11.html#cascade-mode-changes>`_.\n```"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 5]"
    },
    {
      "title": "Collections",
      "description": null,
      "content": {
        "Collections of Simple Types": "You can use the `RuleForEach` method to apply the same rule to multiple items in a collection:\n\n```\npublic class Person \n{\n  public List<string> AddressLines { get; set; } = new List<string>();\n}\n```\n\n```\npublic class PersonValidator : AbstractValidator<Person> \n{\n  public PersonValidator() \n  {\n    RuleForEach(x => x.AddressLines).NotNull();\n  }\n}\n```\n\nThe above rule will run a NotNull check against each item in the `AddressLines` collection.\n\nAs of version 8.5, if you want to access the index of the collection element that caused the validation failure, you can use the special `{CollectionIndex}` placeholder:\n\n```\npublic class PersonValidator : AbstractValidator<Person> \n{\n  public PersonValidator() \n  {\n    RuleForEach(x => x.AddressLines).NotNull().WithMessage(\"Address {CollectionIndex} is required.\");\n  }\n}\n```",
        "Collections of Complex Types": "You can also combine `RuleForEach` with `SetValidator` when the collection is of another complex objects. For example:\n\n```\npublic class Customer \n{\n  public List<Order> Orders { get; set; } = new List<Order>();\n}\n\npublic class Order \n{\n  public double Total { get; set; }\n}\n```\n\n```\npublic class OrderValidator : AbstractValidator<Order> \n{\n  public OrderValidator() \n  {\n    RuleFor(x => x.Total).GreaterThan(0);\n  }\n}\n\npublic class CustomerValidator : AbstractValidator<Customer> \n{\n  public CustomerValidator() \n  {\n    RuleForEach(x => x.Orders).SetValidator(new OrderValidator());\n  }\n}\n```\n\nAlternatively, as of FluentValidation 8.5, you can also define rules for child collection elements in-line using the `ChildRules` method:\n\n```\npublic class CustomerValidator : AbstractValidator<Customer> \n{\n  public CustomerValidator() \n  {\n    RuleForEach(x => x.Orders).ChildRules(order => \n    {\n      order.RuleFor(x => x.Total).GreaterThan(0);\n    });\n  }\n}\n```\n\nYou can optionally include or exclude certain items in the collection from being validated by using the `Where` or `WhereAsync` methods. Note this must come directly after the call to `RuleForEach`:\n\n```\nRuleForEach(x => x.Orders)\n  .Where(x => x.Cost != null)\n  .SetValidator(new OrderValidator());\n```\n\nAs of version 8.2, an alternative to using `RuleForEach` is to call `ForEach` as part of a regular `RuleFor`. With this approach you can combine rules that act upon the entire collection with rules which act upon individual elements within the collection. For example, imagine you have the following 2 rules:\n\n```\n// This rule acts on the whole collection (using RuleFor)\nRuleFor(x => x.Orders)\n  .Must(x => x.Count <= 10).WithMessage(\"No more than 10 orders are allowed\");\n\n// This rule acts on each individual element (using RuleForEach)\nRuleForEach(x => x.Orders)\n  .Must(order => order.Total > 0).WithMessage(\"Orders must have a total of more than 0\")\n```\n\nThe above 2 rules could be re-written as:\n\n```\nRuleFor(x => x.Orders)\n  .Must(x => x.Count <= 10).WithMessage(\"No more than 10 orders are allowed\")\n  .ForEach(orderRule => \n  {\n    orderRule.Must(order => order.Total > 0).WithMessage(\"Orders must have a total of more than 0\")\n  });\n```\n\nWe recommend using 2 separate rules as this is clearer and easier to read, but the option of combining them is available with the `ForEach` method."
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 6]"
    },
    {
      "title": "Conditions",
      "description": null,
      "content": {
        "Conditions": "The `When` and `Unless` methods can be used to specify conditions that control when the rule should execute. For example, this rule on the `CustomerDiscount` property will only execute when `IsPreferredCustomer` is `true`:\n\n```\nRuleFor(customer => customer.CustomerDiscount).GreaterThan(0).When(customer => customer.IsPreferredCustomer);\n```\n\nThe `Unless` method is simply the opposite of `When`.\n\nIf you need to specify the same condition for multiple rules then you can call the top-level `When` method instead of chaining the `When` call at the end of the rule:\n\n```\nWhen(customer => customer.IsPreferred, () => {\n   RuleFor(customer => customer.CustomerDiscount).GreaterThan(0);\n   RuleFor(customer => customer.CreditCardNumber).NotNull();\n});\n```\n\nThis time, the condition will be applied to both rules. You can also chain a call to `Otherwise` which will invoke rules that don't match the condition:\n\n```\nWhen(customer => customer.IsPreferred, () => {\n   RuleFor(customer => customer.CustomerDiscount).GreaterThan(0);\n   RuleFor(customer => customer.CreditCardNumber).NotNull();\n}).Otherwise(() => {\n  RuleFor(customer => customer.CustomerDiscount).Equal(0);\n});\n```\n\nBy default FluentValidation will apply the condition to all preceding validators in the same call to `RuleFor`. If you only want the condition to apply to the validator that immediately precedes the condition, you must explicitly specify this:\n\n```\nRuleFor(customer => customer.CustomerDiscount)\n    .GreaterThan(0).When(customer => customer.IsPreferredCustomer, ApplyConditionTo.CurrentValidator)\n    .EqualTo(0).When(customer => ! customer.IsPreferredCustomer, ApplyConditionTo.CurrentValidator);\n```\n\nIf the second parameter is not specified, then it defaults to `ApplyConditionTo.AllValidators`, meaning that the condition will apply to all preceding validators in the same chain.\n\nIf you need this behaviour, be aware that you must specify `ApplyConditionTo.CurrentValidator` as part of *every* condition. In the following example the first call to `When` applies to only the call to `Matches`, but not the call to `NotEmpty`. The second call to `When` applies only to the call to `Empty`.\n\n```\nRuleFor(customer => customer.Photo)\n    .NotEmpty()\n    .Matches(\"https://wwww.photos.io/\\d+\\.png\")\n    .When(customer => customer.IsPreferredCustomer, ApplyConditionTo.CurrentValidator)\n    .Empty()\n    .When(customer => ! customer.IsPreferredCustomer, ApplyConditionTo.CurrentValidator);\n```"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 7]"
    },
    {
      "title": "Overriding the Message",
      "description": null,
      "content": {
        "Placeholders": "As shown in the example above, the message can contain placeholders for special values such as `{PropertyName}` - which will be replaced at runtime. Each built-in validator has its own list of placeholders.\n\nThe placeholders used in all validators are:\n\n['`{PropertyName}` – Name of the property being validated', '`{PropertyValue}` – Value of the property being validated\\nThese include the predicate validator (`Must` validator), the email and the regex validators.']\n\nUsed in comparison validators: (`Equal`, `NotEqual`, `GreaterThan`, `GreaterThanOrEqual`, etc.)\n\n['`{ComparisonValue}` – Value that the property should be compared to', '`{ComparisonProperty}` – Name of the property being compared against (if any)']\n\nUsed only in the Length validator:\n\n['`{MinLength}` – Minimum length', '`{MaxLength}` – Maximum length', '`{TotalLength}` – Number of characters entered']\n\nFor a complete list of error message placeholders see the [Built in Validators page](built-in-validators). Each built in validator has its own supported placeholders.\n\nIt is also possible to use your own custom arguments in the validation message. These can either be static values or references to other properties on the object being validated. This can be done by using the overload of `WithMessage` that takes a lambda expression, and then passing the values to `string.Format` or by using string interpolation.\n\n```\n//Using constant in a custom message:\nRuleFor(customer => customer.Surname)\n  .NotNull()\n  .WithMessage(customer => string.Format(\"This message references some constant values: {0} {1}\", \"hello\", 5))\n//Result would be \"This message references some constant values: hello 5\"\n\n//Referencing other property values:\nRuleFor(customer => customer.Surname)\n  .NotNull()\n  .WithMessage(customer => $\"This message references some other properties: Forename: {customer.Forename} Discount: {customer.Discount}\");\n//Result would be: \"This message references some other properties: Forename: Jeremy Discount: 100\"\n```\n\nIf you want to override all of FluentValidation's default error messages, check out FluentValidation's support for [Localization](localization)."
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 8]"
    },
    {
      "title": "Custom State",
      "description": null,
      "content": {
        "Custom State": "There may be an occasion where you'd like to return contextual information about the state of your validation rule when it was run. The `WithState` method allows you to associate any custom data with the validation results.\n\nWe could assign a custom state by modifying a line to read:\n\n```\npublic class PersonValidator : AbstractValidator<Person> \n{\n  public PersonValidator() \n  {\n    RuleFor(person => person.Surname).NotNull();\n    RuleFor(person => person.Forename).NotNull().WithState(person => 1234);  \n  }\n}\n```\n\nThis state is then available within the `CustomState` property of the `ValidationFailure`.\n\n```\nvar validator = new PersonValidator();\nvar result = validator.Validate(new Person());\nforeach (var failure in result.Errors) \n{\n  Console.WriteLine($\"Property: {failure.PropertyName} State: {failure.CustomState}\");\n}\n```\n\nThe output would be:\n\n```\nProperty: Surname State:\nProperty: Forename State: 1234\n```\n\nBy default the `CustomState` property will be `null` if `WithState` hasn't been called."
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 9]"
    },
    {
      "title": "Custom Validators",
      "description": null,
      "content": {
        "Predicate Validator": "The simplest way to implement a custom validator is by using the `Must` method, which internally uses the `PredicateValidator`.\n\nImagine we have the following class:\n\n```\npublic class Person {\n  public IList<Pet> Pets {get;set;} = new List<Pet>();\n}\n```\n\nTo ensure our list property contains fewer than 10 items, we could do this:\n\n```\npublic class PersonValidator : AbstractValidator<Person> {\n  public PersonValidator() {\n    RuleFor(x => x.Pets).Must(list => list.Count < 10)\n      .WithMessage(\"The list must contain fewer than 10 items\");\n  }\n}\n```\n\nTo make this logic reusable, we can wrap it an extension method that acts upon any `List<T>` type.\n\n```\npublic static class MyCustomValidators {\n  public static IRuleBuilderOptions<T, IList<TElement>> ListMustContainFewerThan<T, TElement>(this IRuleBuilder<T, IList<TElement>> ruleBuilder, int num) {\n    return ruleBuilder.Must(list => list.Count < num).WithMessage(\"The list contains too many items\");\n  }\n}\n```\n\nHere we create an extension method on `IRuleBuilder<T,TProperty>`, and we use a generic type constraint to ensure this method only appears in intellisense for List types. Inside the method, we call the Must method in the same way as before but this time we call it on the passed-in `RuleBuilder` instance. We also pass in the number of items for comparison as a parameter. Our rule definition can now be rewritten to use this method:\n\n```\nRuleFor(x => x.Pets).ListMustContainFewerThan(10);\n```",
        "Custom message placeholders": "We can extend the above example to include a more useful error message. At the moment, our custom validator always returns the message \"The list contains too many items\" if validation fails. Instead, let's change the message so it returns \"'Pets' must contain fewer than 10 items.\" This can be done by using custom message placeholders. FluentValidation supports several message placeholders by default including `{PropertyName}` and `{PropertyValue}` ([see this list for more](built-in-validators)), but we can also add our own.\n\nWe need to modify our extension method slightly to use a different overload of the `Must` method, one that accepts a `ValidationContext<T>` instance. This context provides additional information and methods we can use when performing validation:\n\n```\npublic static IRuleBuilderOptions<T, IList<TElement>> ListMustContainFewerThan<T, TElement>(this IRuleBuilder<T, IList<TElement>> ruleBuilder, int num) {\n\n  return ruleBuilder.Must((rootObject, list, context) => {\n    context.MessageFormatter.AppendArgument(\"MaxElements\", num);\n    return list.Count < num;\n  })\n  .WithMessage(\"{PropertyName} must contain fewer than {MaxElements} items.\");\n}\n```\n\nNote that the overload of Must that we're using now accepts 3 parameters: the root (parent) object, the property value itself, and the context. We use the context to add a custom message replacement value of `MaxElements` and set its value to the number passed to the method. We can now use this placeholder as `{MaxElements}` within the call to `WithMessage`.\n\nThe resulting message will now be `'Pets' must contain fewer than 10 items.` We could even extend this further to include the number of elements that the list contains like this:\n\n```\npublic static IRuleBuilderOptions<T, IList<TElement>> ListMustContainFewerThan<T, TElement>(this IRuleBuilder<T, IList<TElement>> ruleBuilder, int num) {\n\n  return ruleBuilder.Must((rootObject, list, context) => {\n    context.MessageFormatter\n      .AppendArgument(\"MaxElements\", num)\n      .AppendArgument(\"TotalElements\", list.Count);\n\n    return list.Count < num;\n  })\n  .WithMessage(\"{PropertyName} must contain fewer than {MaxElements} items. The list contains {TotalElements} element\");\n}\n```",
        "Writing a Custom Validator": "If you need more control of the validation process than is available with `Must`, you can write a custom rule using the `Custom` method. This method allows you to manually create the `ValidationFailure` instance associated with the validation error. Usually, the framework does this for you, so it is more verbose than using `Must`.\n\n```\npublic class PersonValidator : AbstractValidator<Person> {\n  public PersonValidator() {\n   RuleFor(x => x.Pets).Custom((list, context) => {\n     if(list.Count > 10) {\n       context.AddFailure(\"The list must contain 10 items or fewer\");\n     }\n   });\n  }\n}\n```\n\nThe advantage of this approach is that it allows you to return multiple errors for the same rule (by calling the `context.AddFailure` method multiple times). In the above example, the property name in the generated error will be inferred as \"Pets\", although this could be overridden by calling a different overload of `AddFailure`:\n\n```\ncontext.AddFailure(\"SomeOtherProperty\", \"The list must contain 10 items or fewer\");\n// Or you can instantiate the ValidationFailure directly:\ncontext.AddFailure(new ValidationFailure(\"SomeOtherProperty\", \"The list must contain 10 items or fewer\");\n```\n\nAs before, this could be wrapped in an extension method to simplify the consuming code.\n\n```\npublic static IRuleBuilderOptionsConditions<T, IList<TElement>> ListMustContainFewerThan<T, TElement>(this IRuleBuilder<T, IList<TElement>> ruleBuilder, int num) {\n\n  return ruleBuilder.Custom((list, context) => {\n     if(list.Count > 10) {\n       context.AddFailure(\"The list must contain 10 items or fewer\");\n     }\n   });\n}\n```",
        "Reusable Property Validators": "In some cases where your custom logic is very complex, you may wish to move the custom logic into a separate class. This can be done by writing a class that inherits from the abstract `PropertyValidator<T,TProperty>` class (this is how all of FluentValidation's built-in rules are defined).\n\n```\n.. note::\n  This is an advanced technique that is usually unnecessary - the `Must` and `Custom` methods explained above are usually more appropriate.\n```\n\nWe can recreate the above example using a custom `PropertyValidator` implementation like this:\n\n```\nusing System.Collections.Generic;\nusing FluentValidation.Validators;\n\npublic class ListCountValidator<T, TCollectionElement> : PropertyValidator<T, IList<TCollectionElement>> {\n    private int _max;\n\n    public ListCountValidator(int max) {\n        _max = max;\n    }\n\n    public override bool IsValid(ValidationContext<T> context, IList<TCollectionElement> list) {\n        if(list != null && list.Count >= _max) {\n            context.MessageFormatter.AppendArgument(\"MaxElements\", _max);\n            return false;\n        }\n\n        return true;\n    }\n\n  public override string Name => \"ListCountValidator\";\n\n    protected override string GetDefaultMessageTemplate(string errorCode)\n        => \"{PropertyName} must contain fewer than {MaxElements} items.\";\n}\n```\n\nWhen you inherit from `PropertyValidator` you must override the `IsValid` method. This method receives two values - the `ValidationContext<T>` representing the current validation run, and the value of the property. The method should return a boolean indicating whether validation was successful. The generic type parameters on the base class represent the root instance being validated, and the type of the property that our custom validator can act upon. In this case we're constraining the custom validator to types that implement `IList<TCollectionElement>` although this can be left open if desired.\n\nNote that the error message to use is specified by overriding `GetDefaultMessageTemplate`.\n\nTo use the new custom validator you can call `SetValidator` when defining a validation rule.\n\n```\npublic class PersonValidator : AbstractValidator<Person> {\n    public PersonValidator() {\n       RuleFor(person => person.Pets).SetValidator(new ListCountValidator<Person, Pet>(10));\n    }\n}\n```\n\nAs with the first example, you can wrap this in an extension method to make the syntax nicer:\n\n```\npublic static class MyValidatorExtensions {\n   public static IRuleBuilderOptions<T, IList<TElement>> ListMustContainFewerThan<T, TElement>(this IRuleBuilder<T, IList<TElement>> ruleBuilder, int num) {\n      return ruleBuilder.SetValidator(new ListCountValidator<T, TElement>(num));\n   }\n}\n```\n\n...which can then be chained like any other validator:\n\n```\npublic class PersonValidator : AbstractValidator<Person> {\n    public PersonValidator() {\n       RuleFor(person => person.Pets).ListMustContainFewerThan(10);\n    }\n}\n```\n\nAs another simpler example, this is how FluentValidation's own `NotNull` validator is implemented:\n\n```\npublic class NotNullValidator<T,TProperty> : PropertyValidator<T,TProperty> {\n\n  public override string Name => \"NotNullValidator\";\n\n  public override bool IsValid(ValidationContext<T> context, TProperty value) {\n    return value != null;\n  }\n\n  protected override string GetDefaultMessageTemplate(string errorCode)\n    => \"'{PropertyName}' must not be empty.\";\n}\n\n```"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 10]"
    },
    {
      "title": "Dependentrules",
      "description": null,
      "content": {
        "Dependent Rules": "By default, all rules in FluentValidation are separate and cannot influence one another. This is intentional and necessary for asynchronous validation to work. However, there may be some cases where you want to ensure that some rules are only executed after another has completed. You can use `DependentRules` to do this.\n\nTo use dependent rules, call the `DependentRules` method at the end of the rule that you want others to depend on. This method accepts a lambda expression inside which you can define other rules that will be executed only if the first rule passes:\n\n```\nRuleFor(x => x.Surname).NotNull().DependentRules(() => {\n  RuleFor(x => x.Forename).NotNull();\n});\n```\n\nHere the rule against Forename will only be run if the Surname rule passes.\n\n_Author's note_: Personally I do not particularly like using dependent rules as I feel it's fairly hard to read, especially with a complex set of rules. In many cases, it can be simpler to use `When` conditions combined with `CascadeMode` to prevent rules from running in certain situations. Even though this can sometimes mean more duplication, it is often easier to read."
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 11]"
    },
    {
      "title": "Dependency Injection",
      "description": null,
      "content": {
        "Automatic registration": {
          "Filtering results": "You can provide an optional filter function that can be used to exclude some validators from automatic registration. For example, to register all validators *except* the `CustomerValidator` you could write the following:\n\n```\nservices.AddValidatorsFromAssemblyContaining<MyValidator>(ServiceLifetime.Scoped, \n    filter => filter.ValidatorType != typeof(CustomerValidator));\n```\n\nThe `CustomerValidator` will not be added to the service provider (but all other validators will)."
        }
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 12]"
    },
    {
      "title": "Custom Error Codes",
      "description": null,
      "content": {
        "ErrorCode and Error Messages": "The `ErrorCode` is also used to determine the default error message for a particular validator. At a high level:\n\n['The error code is used as the lookup key for an error message. For example, a `NotNull()` validator has a default error code of `NotNullValidator`, which used to look up the error messages from the `LanguageManager`. [See the documentation on localization.](localization)', 'If you provide an error code, you could also provide a localized message with the name of that error code to create a custom message.', \"If you provide an error code but no custom message, the message will fall back to the default message for that validator. You're not required to add a custom message.\", 'Using `ErrorCode` can also be used to override the default error message. For example, if you use a custom `Must()` validator, but you\\'d like to reuse the `NotNull()` validator\\'s default error message, you can call `WithErrorCode(\"NotNullValidator\")` to achieve this result.']"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 13]"
    },
    {
      "title": "Including Rules",
      "description": null,
      "content": {
        "Including Rules": "You can include rules from other validators provided they validate the same type. This allows you to split rules across multiple classes and compose them together (in a similar way to how other languages support traits). For example, imagine you have 2 validators that validate different aspects of a `Person`:\n\n```\npublic class PersonAgeValidator : AbstractValidator<Person>  \n{\n  public PersonAgeValidator() \n  {\n    RuleFor(x => x.DateOfBirth).Must(BeOver18);\n  }\n\n  protected bool BeOver18(DateTime date) \n  {\n    //...\n  }\n}\n\npublic class PersonNameValidator : AbstractValidator<Person> \n{\n  public PersonNameValidator() \n  {\n    RuleFor(x => x.Surname).NotNull().Length(0, 255);\n    RuleFor(x => x.Forename).NotNull().Length(0, 255);\n  }\n}\n```\n\nBecause both of these validators are targetting the same model type (`Person`), you can combine them using `Include`:\n\n```\npublic class PersonValidator : AbstractValidator<Person> \n{\n  public PersonValidator()\n   {\n    Include(new PersonAgeValidator());\n    Include(new PersonNameValidator());\n  }\n}\n```\n\n```\n.. note::\n    You can only include validators that target the same type as the root validator.\n```"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 14]"
    },
    {
      "title": "Inheritance Validation",
      "description": null,
      "content": {
        "Limitations": "It's important to note that every subclass that you want to be validated *must be explicitly mapped*. For example, the following would not work:\n\n```\npublic class ContactBaseValidator : AbstractValidator<IContact> \n{\n  public ContactBaseValidatoR() \n  {\n    RuleFor(x => x.Name).NotNull();\n  }\n}\n\npublic class ContactRequestValidator : AbstractValidator<ContactRequest>\n{\n  public ContactRequestValidator()\n  {\n\n    RuleFor(x => x.Contact).SetInheritanceValidator(v => \n    {\n      // THIS WILL NOT WORK.\n      // This will not validate instances of Person or Organisation.\n      v.Add<IContact>(new ContactBaseValidator());\n    });\n  }\n}\n```\n\nIn the above example, this would not correctly validate instances of `Person` or `Organisation` as they have not been explicitly mapped. You must explicitly indicate every subclass that you want to have mapped, as per the first example at the top of the page. "
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 15]"
    },
    {
      "title": "Installation",
      "description": null,
      "content": {
        "Installation": "```\n.. note::\n    If you are upgrading to FluentValidation 12 from an older version, `please read the upgrade notes <upgrading-to-12.html>`_.\n```\n\nBefore creating any validators, you will need to add a reference to FluentValidation.dll in your project. The simplest way to do this is to use either the NuGet package manager, or the dotnet CLI.\n\nUsing the NuGet package manager console within Visual Studio run the following command:\n\n```\nInstall-Package FluentValidation\n```\n\nOr using the .net core CLI from a terminal window:\n\n```\ndotnet add package FluentValidation\n```"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 16]"
    },
    {
      "title": "Localization",
      "description": null,
      "content": {
        "Localization": "Out of the box, FluentValidation provides translations for the default validation messages in several languages. By default, the language specified in the .NET's framework's current UI culture will be used (`CultureInfo.CurrentUICulture`) when translating messages.\n\nYou can also use the `WithMessage` method to specify a localized error message for a single validation rule.\n\nWithMessage\n\nIf you are using Visual Studio's built in support for `.resx` files and their strongly-typed wrappers, then you can localize a message by calling the overload of `WithMessage` that accepts a lambda expression:\n\n```\nRuleFor(x => x.Surname).NotNull().WithMessage(x => MyLocalizedMessages.SurnameRequired);\n```\n\nYou could also use the same approach if you need to obtain the localized message from another source (such as a database) by obtaining the string from within the lambda.\n\nIStringLocalizer\n\nThe above 2 examples assume you're using a strongly-typed wrapper around a resource file, where each static property on the class corresponds to a key within the resource file. This is the \"old\" way of working with resources prior to ASP.NET Core, but is not relevant if you're using ASP.NET Core's `IStringLocalizer`.\n\nIf you are using `IStringLocalizer` to handle localization then all you need to do is inject your localizer into your validator, and use it within a `WithMessage` callback, for example:\n\n```\npublic class PersonValidator : AbstractValidator<Person> \n{\n  public PersonValidator(IStringLocalizer<Person> localizer)\n   {\n    RuleFor(x => x.Surname).NotNull().WithMessage(x => localizer[\"Surname is required\"]);\n  }\n}\n```\n\nDefault Messages\n\nIf you want to replace all (or some) of FluentValidation's default messages then you can do this by implementing a custom version of the `ILanguageManager` interface.\n\nFor example, the default message for the `NotNull` validator is `'{PropertyName}' must not be empty.`. If you wanted to replace this message for all uses of the `NotNull` validator in your application, you could write a custom Language Manager:\n\n```\npublic class CustomLanguageManager : FluentValidation.Resources.LanguageManager\n{\n  public CustomLanguageManager() \n  {\n    AddTranslation(\"en\", \"NotNullValidator\", \"'{PropertyName}' is required.\");\n    AddTranslation(\"en-US\", \"NotNullValidator\", \"'{PropertyName}' is required.\");\n    AddTranslation(\"en-GB\", \"NotNullValidator\", \"'{PropertyName}' is required.\");\n  }\n}\n```\n\nHere we have a custom class that inherits from the base `LanguageManager`. In its constructor we call the `AddTranslation` method passing in the language we're using, the name of the validator we want to override, and the new message.\n\nOnce this is done, we can replace the default LanguageManager by setting the LanguageManager property in the static `ValidatorOptions` class during your application's startup routine:\n\n```\nValidatorOptions.Global.LanguageManager = new CustomLanguageManager();\n```\n\nNote that if you replace messages in the `en` culture, you should consider also replacing the messages for `en-US` and `en-GB` too, as these will take precedence for users from these locales.\n\nThis is a simple example that only replaces one validator's message in English only, but could be extended to replace the messages for all languages. Instead of inheriting from the default LanguageManager, you could also implement the `ILanguageManager` interface directly if you want to load the messages from a completely different location other than the FluentValidation default (for example, if you wanted to store FluentValidation's default messages in a database).\n\nOf course, if all you want to do is replace this message for a single use of a validator, then you could just use `WithMessage(\"'{PropertyName}' is required\");`\n\nContributing Languages\n\nIf you'd like to contribute a translation of FluentValidation's default messages, please open a pull request that adds a language file to the project. The current language files are [located in the GitHub repository](https://github.com/JeremySkinner/FluentValidation/tree/master/src/FluentValidation/Resources/Languages). Additionally you'll need to [add the new language to the default LanguageManager](https://github.com/FluentValidation/FluentValidation/blob/main/src/FluentValidation/Resources/LanguageManager.cs#L38) \n\n[The default English messages are stored here](https://github.com/JeremySkinner/FluentValidation/blob/master/src/FluentValidation/Resources/Languages/EnglishLanguage.cs)\n\nDisabling Localization\n\nYou can completely disable FluentValidation's support for localization, which will force the default English messages to be used, regardless of the thread's `CurrentUICulture`. This can be done in your application's startup routine by calling into the static `ValidatorOptions` class:\n\n```\nValidatorOptions.Global.LanguageManager.Enabled = false;\n```\n\nYou can also force the default messages to always be displayed in a specific language:\n\n```\nValidatorOptions.Global.LanguageManager.Culture = new CultureInfo(\"fr\");\n```"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 17]"
    },
    {
      "title": "Mvc5",
      "description": null,
      "content": {
        "ASP.NET MVC 5": "```\n.. warning::\n   Integration with ASP.NET MVC 5 is no longer supported as of FluentValidation 9. Please migrate to ASP.NET Core.\n```\n\nFluentValidation 8.x provided integration with ASP.NET MVC 5. This is no longer maintained or supported, and is not compatible with FluentValidation 9 or newer.\n\nFor instructions on using these unsupported legacy components with FluentValidation 8, [please review this page](https://github.com/FluentValidation/FluentValidation-LegacyWeb/wiki/MVC-5-Integration)"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 18]"
    },
    {
      "title": "Rulesets",
      "description": null,
      "content": {
        "RuleSets": "RuleSets allow you to group validation rules together which can be executed together as a group whilst ignoring other rules:\n\nFor example, let's imagine we have 3 properties on a Person object (Id, Surname and Forename) and have a validation rule for each. We could group the Surname and Forename rules together in a “Names” RuleSet:\n\n```\n public class PersonValidator : AbstractValidator<Person> \n {\n  public PersonValidator() \n  {\n     RuleSet(\"Names\", () => \n     {\n        RuleFor(x => x.Surname).NotNull();\n        RuleFor(x => x.Forename).NotNull();\n     });\n\n     RuleFor(x => x.Id).NotEqual(0);\n  }\n}\n```\n\nHere the two rules on Surname and Forename are grouped together in a “Names” RuleSet. We can invoke only these rules by passing additional options to the Validate method:\n\n```\nvar validator = new PersonValidator();\nvar person = new Person();\nvar result = validator.Validate(person, options => options.IncludeRuleSets(\"Names\"));\n```\n\n```\n.. note::\n  Many of the methods in FluentValidation are extension methods such as \"Validate\" above and require the FluentValidation namespace to be imported via a using statement, e.g. \"using FluentValidation;\".\n```\n\nThis allows you to break down a complex validator definition into smaller segments that can be executed in isolation. If you call `Validate` without passing a ruleset then only rules not in a RuleSet will be executed.\n\nYou can execute multiple rulesets by passing multiple ruleset names to `IncludeRuleSets`:\n\n```\nvar result = validator.Validate(person, options => \n{\n  options.IncludeRuleSets(\"Names\", \"MyRuleSet\", \"SomeOtherRuleSet\");\n});\n```\n\nYou can also include all the rules not part of a ruleset by calling `IncludeRulesNotInRuleSet`, or by using the special name \"default\" (case insensitive):\n\n```\nvalidator.Validate(person, options => \n{\n  // Option 1: IncludeRulesNotInRuleSet is the equivalent of using the special ruleset name \"default\"\n  options.IncludeRuleSets(\"Names\").IncludeRulesNotInRuleSet();\n  // Option 2: This does the same thing.\n  option.IncludeRuleSets(\"Names\", \"default\");\n});\n```\n\nThis would execute rules in the MyRuleSet set, and those rules not in any ruleset. Note that you shouldn't create your own ruleset called \"default\", as FluentValidation will treat these rules as not being in a ruleset.\n\nYou can force all rules to be executed regardless of whether or not they're in a ruleset by calling `IncludeAllRuleSets` (this is the equivalent of using `IncludeRuleSets(\"*\")` )\n\n```\nvalidator.Validate(person, options => \n{\n  options.IncludeAllRuleSets();\n});\n```\n\n```\n.. note::\n If you include a child validator using \"SetValidator\" it will, by default, inherit the ruleset configuration from the parent validator and cascade through to its own child rules. This means the rulesets will also need to be applied to rules within the child validator. This behaviour can be overridden by passing an explicit override ruleset to the SetValidator call. \n```"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 19]"
    },
    {
      "title": "Severity",
      "description": null,
      "content": {
        "Setting the Severity Level": "Given the following example that validates a `Person` object:\n\n```\npublic class PersonValidator : AbstractValidator<Person>\n{\n  public PersonValidator()\n  {\n    RuleFor(person => person.Surname).NotNull();\n    RuleFor(person => person.Forename).NotNull();\n  }\n}\n```\n\nBy default, if these rules fail they will have a severity of `Error`. This can be changed by calling the `WithSeverity` method. For example, if we wanted a missing surname to be identified as a warning instead of an error then we could modify the above line to:\n\n```\nRuleFor(x => x.Surname).NotNull().WithSeverity(Severity.Warning);\n```\n\nIn version 9.0 and above a callback can be used instead, which also gives you access to the item being validated:\n\n```\nRuleFor(person => person.Surname).NotNull().WithSeverity(person => Severity.Warning);\n```\n\nIn this case, the `ValidationResult` would still have an `IsValid` result of `false`. However, in the list of `Errors`, the `ValidationFailure` associated with this field will have its `Severity` property set to `Warning`:\n\n```\nvar validator = new PersonValidator();\nvar result = validator.Validate(new Person());\nforeach (var failure in result.Errors) \n{\n  Console.WriteLine($\"Property: {failure.PropertyName} Severity: {failure.Severity}\");\n}\n```\n\nThe output would be:\n\n```\nProperty: Surname Severity: Warning\nProperty: Forename Severity: Error\n```\n\nBy default, the severity level of every validation rule is `Error`. Available options are `Error`, `Warning`, or `Info`.\n\nTo set the severity level globally, you can set the `Severity` property on the static `ValidatorOptions` class during your application's startup routine:\n\n```\nValidatorOptions.Global.Severity = Severity.Info;\n```\n\nThis can then be overridden by individual rules."
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 20]"
    },
    {
      "title": "Specific Properties",
      "description": null,
      "content": {
        "Validating specific properties": "If your validator contains rules for several properties you can limit execution to only validate specific properties by using the `IncludeProperties` option:\n\n```\n// Validator definition\npublic class CustomerValidator : AbstractValidator<Customer>\n{\n  public CustomerValidator()\n  {\n    RuleFor(x => x.Surname).NotNull();\n    RuleFor(x => x.Forename).NotNull();\n    RuleForEach(x => x.Orders).SetValidator(new OrderValidator());\n  }\n}\n```\n\n```\nvar validator = new CustomerValidator();\nvalidator.Validate(customer, options => \n{\n  options.IncludeProperties(x => x.Surname);\n});\n```\n\nIn the above example only the rule for the `Surname` property will be executed. \n\nWhen working with sub-properties of collections, you can use a wildcard indexer (`[]`) to indicate all items of a collection. For example, if you wanted to validate the `Cost` property of every order, you could use the following:\n\n```\nvar validator = new CustomerValidator();\nvalidator.Validate(customer, options => \n{\n  options.IncludeProperties(\"Orders[].Cost\");\n});\n```\n\nIf you want more arbitrary grouping of rules you can use [Rule Sets](rulesets) instead. "
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 21]"
    },
    {
      "title": "Start",
      "description": null,
      "content": {
        "Creating your first validator": "To define a set of validation rules for a particular object, you will need to create a class that inherits from `AbstractValidator<T>`, where `T` is the type of class that you wish to validate.\n\nFor example, imagine that you have a Customer class:\n\n```\npublic class Customer \n{\n  public int Id { get; set; }\n  public string Surname { get; set; }\n  public string Forename { get; set; }\n  public decimal Discount { get; set; }\n  public string Address { get; set; }\n}\n```\n\nYou would define a set of validation rules for this class by inheriting from `AbstractValidator<Customer>`:\n\n```\nusing FluentValidation;\n\npublic class CustomerValidator : AbstractValidator<Customer> \n{\n}\n```\n\nThe validation rules themselves should be defined in the validator class's constructor.\n\nTo specify a validation rule for a particular property, call the `RuleFor` method, passing a lambda expression\nthat indicates the property that you wish to validate. For example, to ensure that the `Surname` property is not null,\nthe validator class would look like this:\n\n```\nusing FluentValidation;\n\npublic class CustomerValidator : AbstractValidator<Customer>\n{\n  public CustomerValidator()\n  {\n    RuleFor(customer => customer.Surname).NotNull();\n  }\n}\n```\n\nTo run the validator, instantiate the validator object and call the `Validate` method, passing in the object to validate.\n\n```\nCustomer customer = new Customer();\nCustomerValidator validator = new CustomerValidator();\n\nValidationResult result = validator.Validate(customer);\n\n```\n\nThe `Validate` method returns a ValidationResult object. This contains two properties:\n\n['`IsValid` - a boolean that says whether the validation succeeded.', '`Errors` - a collection of ValidationFailure objects containing details about any validation failures.']\n\nThe following code would write any validation failures to the console:\n\n```\nusing FluentValidation.Results; \n\nCustomer customer = new Customer();\nCustomerValidator validator = new CustomerValidator();\n\nValidationResult results = validator.Validate(customer);\n\nif(! results.IsValid) \n{\n  foreach(var failure in results.Errors)\n  {\n    Console.WriteLine(\"Property \" + failure.PropertyName + \" failed validation. Error was: \" + failure.ErrorMessage);\n  }\n}\n```\n\nYou can also call `ToString` on the `ValidationResult` to combine all error messages into a single string. By default, the messages will be separated with new lines, but if you want to customize this behaviour you can pass a different separator character to `ToString`.\n\n```\nValidationResult results = validator.Validate(customer);\nstring allMessages = results.ToString(\"~\");     // In this case, each message will be separated with a `~`\n```\n\n*Note* : if there are no validation errors, `ToString()` will return an empty string.",
        "Chaining validators": "You can chain multiple validators together for the same property:\n\n```\nusing FluentValidation;\n\npublic class CustomerValidator : AbstractValidator<Customer>\n{\n  public CustomerValidator()\n  {\n    RuleFor(customer => customer.Surname).NotNull().NotEqual(\"foo\");\n  }\n}\n```\n\nThis would ensure that the surname is not null and is not equal to the string 'foo'.",
        "Throwing Exceptions": "Instead of returning a `ValidationResult`, you can alternatively tell FluentValidation to throw an exception if validation fails by using the `ValidateAndThrow` method:\n\n```\nCustomer customer = new Customer();\nCustomerValidator validator = new CustomerValidator();\n\nvalidator.ValidateAndThrow(customer);\n```\n\nThis throws a `ValidationException` which contains the error messages in the Errors property.\n\n*Note* `ValidateAndThrow` is an extension method, so you must have the `FluentValidation` namespace imported with a `using` statement at the top of your file in order for this method to be available.\n\n```\nusing FluentValidation;\n```\n\nThe `ValidateAndThrow` method is helpful wrapper around FluentValidation's options API, and is the equivalent of doing the following:\n\n```\nvalidator.Validate(customer, options => options.ThrowOnFailures());\n```\n\nIf you need to combine throwing an exception with [Rule Sets](rulesets), or validating individual properties, you can combine both options using this syntax:\n\n```\nvalidator.Validate(customer, options => \n{\n  options.ThrowOnFailures();\n  options.IncludeRuleSets(\"MyRuleSets\");\n  options.IncludeProperties(x => x.Name);\n});\n```\n\nIt is also possible to customize type of exception thrown, [which is covered in this section](advanced.html#customizing-the-validation-exception).",
        "Complex Properties": "Validators can be re-used for complex properties. For example, imagine you have two classes, Customer and Address:\n\n```\npublic class Customer \n{\n  public string Name { get; set; }\n  public Address Address { get; set; }\n}\n\npublic class Address \n{\n  public string Line1 { get; set; }\n  public string Line2 { get; set; }\n  public string Town { get; set; }\n  public string Country { get; set; }\n  public string Postcode { get; set; }\n}\n```\n\n... and you define an AddressValidator:\n\n```\npublic class AddressValidator : AbstractValidator<Address> \n{\n  public AddressValidator()\n  {\n    RuleFor(address => address.Postcode).NotNull();\n    //etc\n  }\n}\n```\n\n... you can then re-use the AddressValidator in the CustomerValidator definition:\n\n```\npublic class CustomerValidator : AbstractValidator<Customer> \n{\n  public CustomerValidator()\n  {\n    RuleFor(customer => customer.Name).NotNull();\n    RuleFor(customer => customer.Address).SetValidator(new AddressValidator());\n  }\n}\n```\n\n... so when you call `Validate` on the CustomerValidator it will run through the validators defined in both the CustomerValidator and the AddressValidator and combine the results into a single ValidationResult.\n\nIf the child property is null, then the child validator will not be executed.\n\nInstead of using a child validator, you can define child rules inline, eg:\n\n```\nRuleFor(customer => customer.Address.Postcode).NotNull()\n```\n\nIn this case, a null check will *not* be performed automatically on `Address`, so you should explicitly add a condition\n\n```\nRuleFor(customer => customer.Address.Postcode).NotNull().When(customer => customer.Address != null)\n```"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 22]"
    },
    {
      "title": "Test Extensions",
      "description": null,
      "content": {
        "Using TestValidate": "You can use the `TestValidate` extension method to invoke a validator for testing purposes, and then perform assertions against the result. This makes it easier to write tests for validators.\n\nFor example, imagine the following validator is defined:\n\n```\npublic class PersonValidator : AbstractValidator<Person>\n{\n   public PersonValidator()\n   {\n      RuleFor(person => person.Name).NotNull();\n   }\n}\n```\n\nYou could ensure that this validator works correctly by writing the following tests (using NUnit):\n\n```\nusing NUnit.Framework;\nusing FluentValidation;\nusing FluentValidation.TestHelper;\n\n[TestFixture]\npublic class PersonValidatorTester\n{\n    private PersonValidator validator;\n\n    [SetUp]\n    public void Setup()\n    {\n       validator = new PersonValidator();\n    }\n\n    [Test]\n    public void Should_have_error_when_Name_is_null()\n    {\n      var model = new Person { Name = null };\n      var result = validator.TestValidate(model);\n      result.ShouldHaveValidationErrorFor(person => person.Name);\n    }\n\n    [Test]\n    public void Should_not_have_error_when_name_is_specified()\n    {\n      var model = new Person { Name = \"Jeremy\" };\n      var result = validator.TestValidate(model);\n      result.ShouldNotHaveValidationErrorFor(person => person.Name);\n    }\n}\n```\n\nIf the assertion fails, then a `ValidationTestException` will be thrown.\n\nIf you have more complex tests, you can use the same technique to perform multiple assertions on a single validation result. For example:\n\n```\nvar person = new Person { Name = \"Jeremy\" };\nvar result = validator.TestValidate(person);\n\n// Assert that there should be a failure for the Name property.\nresult.ShouldHaveValidationErrorFor(x => x.Name);\n\n// Assert that there are no failures for the age property.\nresult.ShouldNotHaveValidationErrorFor(x => x.Age);\n\n// You can also use a string name for properties that can't be easily represented with a lambda, eg:\nresult.ShouldHaveValidationErrorFor(\"Addresses[0].Line1\");\n```\n\nYou can also chain additional method calls to the result of `ShouldHaveValidationErrorFor` that test individual components of the validation failure including the error message, severity, error code and custom state:\n\n```\nvar result = validator.TestValidate(person);\n\nresult.ShouldHaveValidationErrorFor(person => person.Name)\n  .WithErrorMessage(\"'Name' must not be empty.\")\n  .WithSeverity(Severity.Error)\n  .WithErrorCode(\"NotNullValidator\");\n```\n\nIf you want to make sure no other validation failures occurred, except specified by conditions, use method `Only` after the conditions:\n\n```\nvar result = validator.TestValidate(person);\n\n// Assert that failures only happened for Name property.\nresult.ShouldHaveValidationErrorFor(person => person.Name).Only();\n\n// Assert that failures only happened for Name property and all have the specified message\nresult.ShouldHaveValidationErrorFor(person => person.Name)\n  .WithErrorMessage(\"'Name' must not be empty.\")\n  .Only();\n```\n\nThere are also inverse methods available (`WithoutMessage`, `WithoutErrorCode`, `WithoutSeverity`, `WithoutCustomState`).",
        "Asynchronous TestValidate": "There is also an asynchronous `TestValidateAsync` method available which corresponds to the regular `ValidateAsync` method. Usage is similar, except the method returns an awaitable `Task` instead."
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 23]"
    },
    {
      "title": "Transform",
      "description": null,
      "content": {
        "Transforming Values": "```\n.. warning::\n  The methods documented below are no longer recommended or supported and will be removed in FluentValidation 12. We instead recommend using computed properties on your model if you need to perform a transformation. For details please see `this GitHub issue <https://github.com/FluentValidation/FluentValidation/issues/2072>`_\n```\n\nAs of FluentValidation 9.5, you can apply a transformation to a property value prior to validation being performed against it. For example, if you have property of type `string` that actually contains numeric input, you could apply a transformation to convert the string value to a number.\n\n```\nTransform(from: x => x.SomeStringProperty, to: value => int.TryParse(value, out int val) ? (int?) val : null)\n    .GreaterThan(10);\n```\n\nThis rule transforms the value from a `string` to a nullable `int` (returning `null` if the value couldn't be converted). A greater-than check is then performed on the resulting value.\n\nSyntactically this is not particularly nice to read, so the logic for the transformation can optionally be moved into a separate method:\n\n```\nTransform(x => x.SomeStringProperty, StringToNullableInt)\n    .GreaterThan(10);\n\nint? StringToNullableInt(string value)\n  => int.TryParse(value, out int val) ? (int?) val : null;\n\n```\n\nThis syntax is available in FluentValidation 9.5 and newer.\n\nThere is also a `TransformForEach` method available, which performs the transformation against each item in a collection."
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 24]"
    },
    {
      "title": "Upgrading To 10",
      "description": null,
      "content": {
        "10.0 Upgrade Guide": "Introduction\n\nFluentValidation 10.0 is a major release that included several breaking changes. Please review this document carefully before upgrading from FluentValidation 9.x to 10.\n\nThe main goals for this release were to improve performance and type safety. To achieve this we have introduced generics throughout FluentValidation's internal model. If you have written custom property validators, or made use of the internal API then you will need to update your code. Users of the public-facing API and fluent interface will be largely unaffected.\n\nPropertyValidatorContext Deprecated\n\nThe `PropertyValidatorContext` class has been deprecated, and various places that previously used this now receive a `ValidationContext<T>` instead. Anywhere that previously called `context.ParentContext` to access the `ValidationContext<T>` can now just use `context` instead. For example:\n\n```\n// Before:\nRuleFor(x => x.Foo).Must((instance, value, context) => \n{\n  return context.ParentContext.RootContextData.ContainsKey(\"Something\");\n});\n\n// After:\nRuleFor(x => x.Foo).Must((instance, value, context) => \n{\n  return context.RootContextData.ContainsKey(\"Something\");\n});\n```\n\nCustom Property Validators\n\nCustom property validators are now generic, and inherit from either `PropertyValidator<T,TProperty>` or `AsyncPropertyValidator<T,TProperty>`. Property validators that inherit from the old non-generic `PropertyValidator` class will continue to work for now, but you will receive a deprecation warning. We recommend migrating to the new generic classes for better performance and support going forward. The non-generic version will be removed in FluentValidation 11. If you currently inherit from `AsyncValidatorBase` then you'll need to migrate as part of upgrading to 10.0\n\nThe following changes should be made in order to migrate:\n\n['The class should inherit from `PropertyValidator<T,TProperty>` (or `AsyncPropertyValidator<T,TProperty>`)', 'The method signature for `IsValid` should be updated', 'The method signature for `GetDefaultMessageTemplate` should be updated', 'The `Name` property should be overridden.']\n\nThe following example shows a custom property validator before and after migration.\n\n```\n// Before:\npublic class NotNullValidator : PropertyValidator\n{\n  protected override bool IsValid(PropertyValidatorContext context)\n  {\n    return context.PropertyValue != null;\n  }\n\n  protected override string GetDefaultMessageTemplate()\n    => \"A value for {PropertyName} is required\";\n}\n\n// After:\npublic class NotNullValidator<T,TProperty> : PropertyValidator<T, TProperty>\n{\n  public override string Name => \"NotNullValidator\";\n\n  public override bool IsValid(ValidationContext<T> context, TProperty value)\n  {\n    return value != null;\n  }\n\n  protected override string GetDefaultMessageTemplate(string errorCode)\n    => \"A value for {PropertyName} is required\";\n}\n```\n\nValidationResult.Errors type change \n\nThe `Errors` property on the `ValidationResult` class has been changed from `IList<ValidationFailure>` to `List<ValidationFailure>`. \n\nChanges to property validator metadata\n\nIn previous versions of FluentValidation, a property validator's configuration and the property validator itself were part of the same class (`PropertyValidator`). In FluentValidation 10, these are now separate. The validator itself that performs the work is either an `IPropertyValidator<T,TProperty>` or an `IAsyncPropertyValidator<T,TProperty>` and their configuration is exposed via a `RuleComponent`. Note there is still a non-generic `IPropertyValidator` interface available implemented by both `IPropertyValidator<T,TProperty>` and `IAsyncPropertyValidator<T,TProperty>` but it has fewer properties available.\n\nVarious methods and properties that previously returned an `IPropertyValidator` now return a tuple of `(IPropertyValidator Validator, IRuleComponent Options)` where previously they returned an `IPropertyValidator`:\n\n['`IValidatorDescriptor.GetMembersWithValidators`', '`IValidatorDescriptor.GetValidatorsForMember`']\n\nWhen accessing property validators via a rule instance, you must now go via a collection of components:\n\n```\n// Before:\nIValidationRule rule = ...;\nforeach (IPropertyValidator propertyValidator in rule.Validators) \n{\n  // ...\n}\n\n// After:\nIValidationRule rule = ...;\nforeach (IRuleComponent component in rule.Componetnts) \n{\n  IPropertyValiator propertyValidator = component.Validator;\n}\n```\n\nWhen accessing the current property validator instance on a rule, you must now go via the `Current` property to get the component first.\n\n```\n// before:\nPropertyRule rule = ...;\nIPropertyValidator currentValidator = rule.CurrentValidator;\n\n// after:\nIValidationRule<T,TProperty> rule = ...;\nRuleComponent<T, TProperty> component = rule.Current;\nIPropertyValidator currentValidator = component.CurrentValidator;\n```\n\nTransform syntax changes\n\nThe old `Transform` syntax has been removed. See [https://docs.fluentvalidation.net/en/latest/transform.html](transform)\n\nDI changes\n\nValidators are now registered as `Scoped` rather than `Transient` when using the ASP.NET integration.\n\nChanges to Interceptors\n\n`IValidatorInterceptor` and `IActionContextValidatorInterceptor` have been combined.\nThe methods in `IValidatorInterceptor` now accept an `ActionContext` as their first parameter instead of a `ControllerContext`, and `IActionContextValidatorInterceptor` has been removed.\n\nChanges to ASP.NET client validator adaptors\n\nThe signature for adding an ASP.NET Client Validator factories has changed to receive a rule component instead of a property validator. Additionally, as property validator instances are now generic, the lookup key should be a non-generic interface implemented by the property validator.\n\n```\n\n// Before:\npublic class MyCustomClientsideAdaptor : ClientValidatorBase\n{\n  public MyCustomClientsideAdaptor(PropertyRule rule, IPropertyValidator validator)\n  : base(rule, validator)\n  {\n\n  }\n\n  public override void AddValidation(ClientModelValidationContext context)\n  {\n    // ...\n  }\n}\n\nservices.AddMvc().AddFluentValidation(fv =>\n{\n  fv.ConfigureClientsideValidation(clientSide =>\n  {\n    clientSide.Add(typeof(MyCustomPropertyValidator), (context, rule, validator) => new MyCustomClientsideAdaptor(rule, validator));\n  })\n})\n\n\n// after:\npublic class MyCustomClientsideAdaptor : ClientValidatorBase\n{\n  public MyCustomClientsideAdaptor(IValidationRule rule, IRuleComponent component)\n  : base(rule, component)\n  {\n\n  }\n\n  public override void AddValidation(ClientModelValidationContext context)\n  {\n    // ...\n  }\n}\n\nservices.AddMvc().AddFluentValidation(fv =>\n{\n  fv.ConfigureClientsideValidation(clientSide =>\n  {\n    clientSide.Add(typeof(IMyCustomPropertyValidator), (context, rule, component) => new MyCustomClientsideAdaptor(rule, component));\n  })\n})\n\n```\n\nThe internal API\n\nParts of FluentValidation's internal API have been marked as `internal` which were previously public. This has been done to allow us to evolve and change the internal model going forward. The following classes are affected:\n\n['`RuleBuilder`', '`PropertyRule`', '`CollectionPropertyRule`', '`IncludeRule`']\n\nFor the majority of cases, if you accessed these classes directly in your code you should be able to use our metadata interfaces to achieve the same result. These include the following:\n\n['`IValidationRule`', '`IValidationRule<T>`', '`IValidationRule<T,TProperty>`', '`ICollectionRule<T, TElement>`', '`IIncludeRule`']\n\nAdditionally the following methods have been removed from rule instances:\n\n['`RemoveValidator`', '`ReplaceValidator`']\n\nRemoval of deprecated code\n\nSeveral classes, interfaces and methods that were deprecated in FluentValidation 9 and have now been removed:\n\nRelated to the generation of error messages, the following have been removed. Alternative methods that receive callbacks are available instead:\n\n['`IStringSource`', '`LazyStringSource`', '`LanguageStringSource`', '`StaticStringSource`']\n\nThe following additional unused classes and interfaces have been removed:\n\n['`Language`', '`ICommonContext`']\n\nThe following methods and properties have been removed:\n\n['`ValidationFailure.FormattedMessageArguments`', '`MessageFormatter.AppendAdditionalArguments`', '`MemberNameValidatorSelector.FromExpressions`', 'Various utility and extension methods that were previously used throughout the internal API, such as `CooerceToNonGeneric`']\n\nSeveral extension methods that provided overloads of the `Validate` method that were previously deprecated have been removed. Replacements are available:\n\n```\n// Validating only specific properties.\n// Before:\nvalidator.Validate(instance, x => x.SomeProperty, x => x.SomeOtherProperty);\nvalidator.Validate(instance, \"SomeProperty\", \"SomeOtherProperty\");\n\n// After:\nvalidator.Validate(instance, v =>\n{\n  v.IncludeProperties(x => x.SomeProperty, x => x.SomeOtherProperty);\n});\n\nvalidator.Validate(instance, v =>\n{\n  v.IncludeProperties(\"SomeProperty\", \"SomeOtherProperty\");\n});\n\n// Validating by ruleset:\n// Before (comma-delmited string to separate multiple rulesets):\nvalidator.Validate(instance, ruleSet: \"SomeRuleSet,AnotherRuleSet\");\n\n// After:\n// Separate parameters for each ruleset.\nvalidator.Validate(instance, v => \n{\n  v.IncludeRuleSets(\"SomeRuleSet\", \"AnotherRuleSet\")\n});\n\n```\n\nOther changes\n\n['`ChildValidatorAdaptor.GetValidator` is non-generic again (as it was in FV 8.x)', 'The `RuleSets` property on `IValidationRule` instances can now be null. In previous versions this would be initialized to an empty array.']"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 25]"
    },
    {
      "title": "Upgrading To 11",
      "description": null,
      "content": {
        "11.0 Upgrade Guide": "Introduction\n\nFluentValidation 11.0 is a major release that included several breaking changes. Please review this document carefully before upgrading from FluentValidation 10.x to 11.\n\nThere were 3 main goals for this release:\n\n['Removing deprecated code and support for obsolete platforms', 'Update sync-over-async workflows to clearly throw an exception', 'Remove ambiguity in handling of `CascadeMode` settings']\n\nBelow is a summary of all the changes in this release:\n\nChanges in supported platforms\n\n['.NET Core 2.1 is no longer supported as Microsoft has stopped support for this platform.']\n\nSync-over-async now throws an exception\n\nIn FluentValidation 10.x and older, if you attempted to run an asynchronous validator synchronously, the asynchronous rules would silently be run synchronously. This was unintutive and would lead to deadlocks. \n\nStarting in FluentValidation 11.0, validators that contain asynchronous rules will now throw a `AsyncValidatorInvokedSynchronouslyException` if you attempt to invoke them synchronously. You must invoke these validators asynchronously.\n\nThis affects rules that contain any of the following:\n\n['Calls to `MustAsync`', 'Calls to `WhenAsync` and `UnlessAsync`', 'Calls to `CustomAsync`', 'Use of any custom async validators ']\n\nOnFailure and OnAnyFailure removed\n\nThe deprecated methods `OnFailure` and `OnAnyFailure` have been removed.\n\nThese were callbacks that could be used to define an action that would be called when a particular rule fails. These methods were deprecated in 10.x as they allowed the standard FluentValidation workflow to be bypassed, and additionally they have caused various maintenance issues since they were introduced. \n\nIf you were previously using `OnFailure` or `OnAnyFailure` to perform custom logic after validation, we recommend using a `Custom` validator instead.\n\nTest Helper changes\n\nThe deprecated extension methods `validator.ShouldHaveValidationErrorFor` and `validator.ShouldNotHaveValidationErrorFor` have been removed. The recommended alternative is to use `TestValidate` instead, [which is covered in the documentation here](https://docs.fluentvalidation.net/en/latest/testing.html).\n\nCascade Mode Changes\n\nThe `CascadeMode` properties on `AbstractValidator` and `ValidatorOptions.Global` have been deprecated and replaced with the properties `RuleLevelCascadeMode` and `ClassLevelCascadeMode` which provide finer-grained control for setting the cascade mode.\n\nIf you are currently setting `ValidatorOptions.Global.CascadeMode` to `Continue` or `Stop`, you can simply replace this with\n\n```\nValidatorOptions.Global.DefaultClassLevelCascadeMode = CascadeMode.<YourCurrentValue>;\nValidatorOptions.Global.DefaultRuleLevelCascadeMode = CascadeMode.<YourCurrentValue>;\n```\n\nIf you are currently setting it to `StopOnFirstFailure`, replace it with\n\n```\nValidatorOptions.Global.DefaultClassLevelCascadeMode = CascadeMode.Continue; // Not actually needed as this is the default. Just here for completeness.\nValidatorOptions.Global.DefaultRuleLevelCascadeMode = CascadeMode.Stop;\n```\n\nSimilarly, if you are currently setting `AbstractValidator.CascadeMode` to `Continue` or `Stop`, replace this with\n\n```\nClassLevelCascadeMode = CascadeMode.<YourCurrentValue>;\nRuleLevelCascadeMode = CascadeMode.<YourCurrentValue>;\n```\n\nIf you are currently setting it to `StopOnFirstFailure`, replace it with\n\n```\nClassLevelCascadeMode = CascadeMode.Continue;\nRuleLevelCascadeMode = CascadeMode.Stop;\n```\n\nIf you are calling `.Cascade(CascadeMode.StopOnFirstFailure)` in a rule chain, replace `StopOnFirstFailure` with `Stop` (this has always had the same behavior at rule-level since `Stop` was introduced anyway).\n\nAll of the changes described above are exactly what the code does now anyway - e.g. if you set `AbstractValidator.CascadeMode` to `Stop`, it sets `AbstractValidator.DefaultRuleLevelCascadeMode` and `AbstractValidator.DefaultClassLevelCascadeMode` to `Stop`, and doesn't use `AbstractValidator.CascadeMode` in any logic internally.\n\nYou may also be able to remove some now-unneeded calls to `.Cascade` at rule-level. For example, if you have the cascade mode at validator class-level set to `Continue`, and are repeating `.Cascade(CascadeMode.Stop[/StopOnFirstFailure])` for each rule, you can now replace this with\n\n```\nClassLevelCascadeMode = CascadeMode.Continue;\nRuleLevelCascadeMode = CascadeMode.Stop;\n```\n\n...or their global default equivalents. \n\nSee [this page in the documentation](https://docs.fluentvalidation.net/en/latest/conditions.html#setting-the-cascade-mode) for details of how cascade modes work.\n\nAs `StopOnFirstFailure` is deprecated and scheduled for removal, it cannot be assigned to either of the two new `AbstractValidator` properties or their global equivalents (it still can be assigned to the also-deprecated `AbstractValidator.CascadeMode`). Attempting to set the new properties to `StopOnFirstFailure` will simply result in `Stop` being used instead.\n\nMessageBuilder changes\n\nIf you use the `MessageBuilder` functionality to provide custom logic for error message creation then please note that as of 11.0 you can only have a single `MessageBuilder` associated with a rule chain. This property is also now set-only. In previous versions you may have had code like this:\n\n```\nreturn ruleBuilder.Configure(rule => {\n  var originalMessageBuilder = rule.MessageBuilder;\n  rule.MessageBuilder = context => {\n    \n    // ... some custom logic in here.\n    \n    return originalMessageBuilder?.Invoke(context) ?? context.GetDefaultMessage();\n  };\n});\n```\n\nNow as this property is set-only you'll need to update it to remove references to `originalMessageBuilder`:\n\n```\nreturn ruleBuilder.Configure(rule => {\n  rule.MessageBuilder = context => {\n    // ... some custom logic in here.\n    return context.GetDefaultMessage();\n  };\n});\n```\n\nThis means you can no longer chain MessageBuilders together, and whichever one is set last will be the only one associated with the rule, so please confirm that you aren't relying on the previous behaviour before making this change. \n\nASP.NET Core Integration changes\n\nThe deprecated property `RunDefaultMvcValidationAfterFluentValidationExecutes` within the ASP.NET Configuration has been removed. \n\nIf you were making use of this property, you should use `DisableDataAnnotationsValidation` instead. Note that this property is the inverse of the previous behaviour:\n\n```\n// Before:\nservices.AddFluentValidation(fv => {\n  fv.RunDefaultMvcValidationAfterFluentValidationExecutes = false;\n});\n\n// After:\nservices.AddFluentValidation(fv => {\n  fv.DisableDataAnnotationsValidation = true;\n});\n\n```\n\nRemoval of backwards compatibility property validator layer\n\nThe non-generic `PropertyValidator` class (and associated classes/helpers) have been removed. These classes were deprecated in 10.0. If you are still using this class, you should migrate to the generic `PropertyValidator<T,TProperty>` instead. \n\nInternal API Changes\n\nSeveral of the methods in the Internal API have been removed. These changes don't affect use of the public fluent interface, but may impact library developers or advanced users.\n\n[\"`IValidationRule<T,TProperty>.CurrentValidator` has been removed (use the `Current` property instead)\\n-`IValidationRule<T,TProperty>.Current` now returns an `IRuleComponent<T,TProperty>` interface instead of `RuleComponent<T,TProperty>` (necessary to support variance) \\n-`IValidationRule<T,TProperty>.MessageBuilder`'s argument is now an `IMessageBuilderContext<T,TProperty>` interface instead of `MessageBuilderContext<T,TProperty>` class (necessary to support variance)\", '`IValidationRule<T,TProperty>.MessageBuilder` is now set-only, and has no getter exposed (needed to support variance), meaning you can only have one message builder per rule chain. ', '`IRuleComponent<T,TProperty>.CustomStateProvider` is now set-only to support variance', '`IRuleComponent<T,TProperty>.SeverityProvider` is now set-only to support variance', '`GetErrorMessage` is no longer exposed on `IRuleComponent<T,TProperty>`', 'Remove deprecated `Options` property from `RuleComponent`', \"The `MemberAccessor` class has been removed as it's no longer used\"]"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 26]"
    },
    {
      "title": "Upgrading To 12",
      "description": null,
      "content": {
        "12.0 Upgrade Guide": "Introduction\n\nFluentValidation 12.0 is a major release that included several breaking changes. Please review this document carefully before upgrading from FluentValidation 11.x to 12.\n\nThe main goal of this release was removal of deprecated code and removal of support for obsolete platforms. There are no new features in this release.\n\nChanges in supported platforms\n\nSupport for the following platforms has been removed:\n\n[\".NET Core 3.1 (Microsoft's support ended in December 2022)\", \".NET 5 (Microsoft's support ended in November 2022)\", \".NET 6 (Microsoft's support ended in November 2024)\", \".NET 7 (Microsoft's support ended in November 2024)\", '.NET Standard 2.0/2.1']\n\n.NET 8 is now the minimum supported version.\n\nIf you still need .NET Standard 2.0 compatibility then you will need to continue to use FluentValidation 11.x and only upgrade to FluentValidation 12 once you've moved to a more modern version of .NET.  \n\nRemoval of the Transform and TransformForEach methods\n\nThe `Transform` and `TransformForEach` methods deprecated in 11.x have been removed. For details on how to migrate see [https://github.com/FluentValidation/FluentValidation/issues/2072](https://github.com/FluentValidation/FluentValidation/issues/2072)\n\nRemoval of CascadeMode.StopOnFirstFailure\n\nThe `StopOnFirstFailure` cascade option was deprecated in FluentValidation 11.0 and has now been removed, along with the `AbstractValidator.CascadeMode` and `ValidatorOptions.Global.CascadeMode` properties which were also deprecated in 11.0. \n\nIf were previously setting `ValidatorOptions.Global.CascadeMode` to `Continue` or `Stop`, you can simply replace this with the following:\n\n```\nValidatorOptions.Global.DefaultClassLevelCascadeMode = CascadeMode.<YourCurrentValue>;\nValidatorOptions.Global.DefaultRuleLevelCascadeMode = CascadeMode.<YourCurrentValue>;\n```\n\nIf you were previously setting it to `StopOnFirstFailure`, replace it with the following:\n\n```\nValidatorOptions.Global.DefaultRuleLevelCascadeMode = CascadeMode.Stop;\n```\n\nSimilarly, if you were previously setting `AbstractValidator.CascadeMode` to `Continue` or `Stop`, replace this with the following:\n\n```\nClassLevelCascadeMode = CascadeMode.<YourCurrentValue>;\nRuleLevelCascadeMode = CascadeMode.<YourCurrentValue>;\n```\n\nIf you were previously setting it to `StopOnFirstFailure`, replace it with the following:\n\n```\nClassLevelCascadeMode = CascadeMode.Continue;\nRuleLevelCascadeMode = CascadeMode.Stop;\n```\n\nIf you were calling `.Cascade(CascadeMode.StopOnFirstFailure)` in a rule chain, replace `StopOnFirstFailure` with `Stop`.\n\nRemoval of InjectValidator and related methods\n\nThe `InjectValidator` method was deprecated in 11.x and removed in 12.0.\n\nThis method allowed you to implicitly inject a child validator from the ASP.NET Service Provider:\n\n```\npublic class PersonValidator : AbstractValidator<Person> \n{\n  public PersonValidator() \n  {\n    RuleFor(x => x.Address).InjectValidator();\n  }\n}\n```\n\nAssuming that the address property is of type `Address`, the above code would attempt to resolve an `IValidator<Address>` and use this to validator the `Address` property. This method can only be used when working with ASP.NET MVC's auto-validation feature and cannot be used in other contexts. \n\nInstead of using `InjectValidator`, you should instead use a more traditional constructor injection approach, which is not just limited to ASP.NET MVC:\n\n```\npublic class PersonValidator : AbstractValidator<Person> \n{\n  public PersonValidator(IValidator<Address> addressValidator) \n  {\n    RuleFor(x => x.Address).SetValidator(addressValidator);\n  }\n}\n```\n\nRemoval of AbstractValidator.EnsureInstanceNotNull\n\nIn previous versions of FluentValidation it was possible to override the `AbstractValidator.EnsureInstanceNotNull` method to disable FluentValidation's root-model null check. The ability to do this was deprecated in 11.5.x and has now been removed. For further details please see [https://github.com/FluentValidation/FluentValidation/issues/2069](https://github.com/FluentValidation/FluentValidation/issues/2069)\n\nChanges to the Serbian language translations\n\nThe existing Serbian translations have been renamed to Serbian (Latin) and are now available under the `sr-Latn` language code. A new Serbian (Cyrillic) language has been added, which is now the default for the `sr` language code. \n\nOther breaking API changes \n\n['The `ITestValidationContinuation` interface now exposes a `MatchedFailures` property (as well as the existing `UnmatchedFailures`)', 'The `ShouldHaveAnyValidationError` method has been renamed to `ShouldHaveValidationErrors`', '`ShouldNotHaveAnyValidationErrors` and `ShouldHaveValidationErrors` are now instance methods on `TestValidationResult`, instead of extension methods. ']"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 27]"
    },
    {
      "title": "Upgrading To 8",
      "description": null,
      "content": {
        "8.0 Upgrade Guide": "Introduction\n\nFluentValidation 8.0 is a major release that included several breaking changes. Please review this document before upgrading from FluentValidation 7.x to 8.\n\nAsynchronous Validation updates\n\nThere have been several major underlying changes to the asynchronous validation workflow in FluentValidation 8. These should not have any impact to any existing asynchronous code other than that some methods now take a `CancellationToken` when they didn't before.\n\nThese changes were made to remove the internal dependency on the old Microsoft `TaskHelper` classes and use `async/await` instead.\n\nSetCollectionValidator is deprecated\n\nInstead of using `SetCollectionValidator` you should use FluentValidation's `RuleForEach` support instead:\n\nFluentValidation 7:\n\n```\nRuleFor(x => x.AddressLines).SetCollectionValidator(new AddressLineValidator());\n```\n\nFluentValidation 8:\n\n```\nRuleForEach(x => x.AddressLines).SetValidator(new AddressLineValidator());\n```\n\nWhy was this done?\n\n`SetCollectionValidator` was added to FluentValidation in its initial versions to provide a way to use a child validator against each element in a collection. `RuleForEach` was added later and provides a more comprehensive way of validating collections (as you can define in-line rules with RuleForEach too). It doesn't make sense to provide 2 ways to do the same thing.\n\nSeveral properties have been removed from PropertyValidator\n\n`CustomStateProvider`, `Severity`, `ErrorMessageSource` and `ErrorCodeSource` are no longer directly exposed on `PropertyValidator`, you should now access them via the `Options` property on `PropertyValidator` instead.\n\nWhy was this done?\n\nIt allows extra options/configuration to be added to property validators without introducing breaking changes to the interface going forward.\n\nValidatorAttribute and AttributedValidatorFactory have been moved to a separate package\n\nUse of the `ValidatorAttribute` to wire up validators is no longer recommended and have been moved to a separate `FluentValidation.ValidatorAttribute` package.\n\n['In ASP.NET Core projects, you should use the service provider to wire models to their validators (this has been the default behaviour for ASP.NET Core projects since FluentValidation 7)', 'For desktop or mobile applications, we recommend using an IoC container to wire up validators, although you can still use the attribute approach by explicitly installing the `FluentValidation.ValidatorAttribute` package.', 'In legacy ASP.NET projects (MVC 5 and WebApi 2), the ValidatorAttribute is still the default approach, and the `FluentValidation.ValidatorAttribute` package will be automatically installed for compatibility. However, we recommend using an IoC container instead if you can.']\n\nValidating properties by path\n\nYou can now validate specific properties using a full path, eg:\n\n```\nvalidator.Validate(customer, \"Address.Line1\", \"Address.Line2\");\n```\n\nValidating a specific ruleset with SetValidator\n\nPreviously, if you defined a child validator with `SetValidator`, then whichever ruleset you invoked on the parent validator will cascade to the child validator.\nNow you can explicitly define which ruleset will run on the child:\n\n```\nRuleFor(x => x.Address).SetValidator(new AddressValidator(), \"myRuleset\");\n```\n\nMany old and deprecated methods have been removed\n\nFluentValidation 8 removes many old/deprecated methods that have been marked as obsolete for a long time.\n\n['Removed the pre-7 way of performing custom validation (`Custom` and `CustomAsync`). Use `RuleFor(x => x).Custom()` instead. [See the section on Custom Validators](/custom-validators)', 'The old localization mechanism that was deprecated with the release of FluentValidation 7. This included several overloads of `WithLocalizedName` and `WithLocalizedMessage`. [See the section on localization for more details](/localization).', 'The `RemoveRule`, `ReplaceRule` and `ClearRules` methods that have been marked obsolete for many years (FluentValidation does not offer a replacement for these as runtime modification of validation rules is not recommended or supported in any way)', \"Removed various async method overloads that didn't accept a `CancellationToken` (use the overloads that do accept them instead.)\"]\n\nOther changes\n\n`IStringSource.GetString` now receives a context, instead of a model. If you have custom `IStringSource` implementations, you will need to update them."
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 28]"
    },
    {
      "title": "Upgrading To 9",
      "description": null,
      "content": {
        "9.0 Upgrade Guide": "Introduction\n\nFluentValidation 9.0 is a major release that included several breaking changes. Please review this document before upgrading from FluentValidation 8.x to 9.\n\nSupported Platforms\n\nSupport for the following platforms has been dropped:\n\n['netstandard1.1', 'netstandard1.6', 'net45']\n\nFluentValidation still supports netstandard2 and net461, meaning that it'll run on .NET Core 2.0 or higher (3.1 recommended), or .NET Framework 4.6.1 or higher.\n\nFluentValidation.AspNetCore requires .NET Core 2.1 or 3.1 (3.1 recommended).\n\nIntegration with MVC5/WebApi 2 is no longer supported - both the FluentValidation.Mvc5 and FluentValidation.WebApi packages were deprecated with the release of FluentValidation 8, but they will now no longer receive further updates. They will continue to run on .NET Framework 4.6.1 or higher, but we recommend migrating to .NET Core as soon as possible.\n\nDefault Email Validation Mode Changed\n\nFluentValidation supports 2 methods for validating email addresses.\n\nThe first is compatible with .NET Core's `EmailAddressAttribute` and performs a simple check that an email address contains an `@` character. The second uses a regular expression that is mostly compatible with .NET 4.x's `EmailAddressAttribute`, which also used a regular expression.\n\nIn FluentValidation 8 and older, the regex-based email validation was the default. As of 9.0, the ASP.NET Core-compatible email validator is now the default. This change was made to be consistent with ASP.NET Core's default behaviour.\n\nIf you still want to validate email addresses using the old regular expression, you can specify `RuleFor(customer => customer.Email).EmailAddress(EmailValidationMode.Net4xRegex);`. This will give a deprecation warning.\n\n[See the documentation on the email validator](built-in-validators.html#email-validator) for more details on why regular expressions shouldn't be used for validating email addresses.\n\nTestHelper updates\n\nThe TestHelper has been updated with several syntax improvements. It is now possible to chain additional assertions on to `ShouldHaveValidationErrorFor` and `ShouldNotHaveValidationErrorFor`, eg:\n\n```\nvar validator = new InlineValidator<Person>();\nvalidator.RuleFor(x => x.Surname).NotNull().WithMessage(\"required\");\nvalidator.RuleFor(x => x.Address.Line1).NotEqual(\"foo\");\n\n// New advanced test syntax\nvar result = validator.TestValidate(new Person { Address = new Address()) };\nresult.ShouldHaveValidationErrorFor(x => x.Surname).WithMessage(\"required\");\nresult.ShouldNotHaveValidationErrorFor(x => x.Address.Line1);\n```\n\n[See the documentation for full details on the Test Helper](testing)\n\nEqual/NotEqual string comparisons\n\nFluentValidation 4.x-8.x contained a bug where using `NotEqual`/`Equal` on string properties would perform a culture-specific check, which would lead to unintented results. 9.0 reverts the bad change which introduced this several years ago. An ordinal string comparison will now be performed instead.\n\n[See the documentation for further details.](built-in-validators.html#equal-validator)\n\nRemoval of non-generic Validate overload\n\nThe `IValidator.Validate(object model)` overload has been removed to improve type safety. If you were using this method before, you can use the overload that accepts an `IValidationContext` instead:\n\n```\nvar context = new ValidationContext<object>(model);\nvar result = validator.Validate(context);\n```\n\nRemoval of non-generic ValidationContext.\n\nThe non-generic `ValidationContext` has been removed. Anywhere that previously used this class will either accept a `ValidationContext<T>` or a non-generic `IValidationContext` interface instead. If you previously made use of this class in custom code, you will need to update it to use one of these as appropriate.\n\nTransform updates\n\nThe `Transform` method can now be used to transform a property value to a different type prior to validation occurring. [See the documentation for further details.](transform)\n\nSeverity with callback\n\nPrior to 9.0, changing a rule's severity required hard-coding the severity:\n\n```\nRuleFor(x => x.Surname).NotNull().WithSeverity(Severity.Warning);\n```\n\nAlternatively, this can now be generated from a callback, allowing the severity to be dynamically determined:\n\n```\nRuleFor(x => x.Surname).NotNull().WithSeverity(x => Severity.Warning);\n```\n\nChanges to the ScalePrecisionValidator\n\nThe algorithm used by the `ScalePrecision` validator has been updated to match SQL Server and other RDBMS systems. The algorithm now correctly checks how many digits are to the left of the decimal point, which it didn't do before. \n\nChildValidatorAdaptor and IncludeRule now have generic parameters\n\nThe `ChildvalidatorAdaptor` and `IncludeRule` classes now have generic type parameters. This will not affect users of the public API, but may affect anyone using the internal API. \n\nRemoved inferring property names from [Display] attribute\n\nOlder versions of FluentValidation allowed inferring a property's name from the presence of the `[Display]` or `[DisplayName]` attributes on the property. This behaviour has been removed as it causes conflicts with ASP.NET Core's approach to localization using these attributes.\n\nIf you want to preserve this old behaviour, you can use a custom display name resolver which can be set during your application's startup routine:\n\n```\nFluentValidation.ValidatorOptions.DisplayNameResolver = (type, memberInfo, expression) => {\n    return memberInfo.GetCustomAttribute<System.ComponentModel.DataAnnotations.DisplayAttribute>()?.GetName();\n};\n```\n\nComparisonProperty formatting\n\nThe `{ComparisonProperty}` error message placeholder (used in various validators that compare two properties, such as `LessThanOrEqual`) is now formatted consistently with the `{PropertyName}` placeholder, so PascalCased property names will be split.\n\nRenamed ShouldValidateAsync\n\nRenamed the `PropertyValidator.ShouldValidateAsync` method to `ShouldValidateAsynchronously` to indicate that this is not an async method, which is usually denoted by the Async suffix.\n\nRemoval of WithLocalizedMessage\n\nThis is only relevant if you use RESX-based localization with strongly-typed wrapper classes generated by Visual Studio. Older versions of FluentValidation allowed the use of specifying a resource name and resource type in a call to `WithLocalizedMessage`:\n\n```\nRuleFor(x => x.Surname).NotNull().WithLocalizedMessage(typeof(MyLocalizedMessages), \"SurnameRequired\");\n```\n\nThis syntax has been superceded by the callback syntax. To access the localized messages with a strongly-typed wrapper, you should now explicitly access the wrapper property inside a callback:\n\n```\nRuleFor(x => x.Surname).NotNull().WithMessage(x => MyLocalizedMessages.SurnameRequired);\n```\n\nNote that support for localization with `IStringLocalizer` is unchanged.\n\n[Full documentation on localization.](localization)\n\nSetCollectionValidator removed\n\n`SetCollectionValidator` has been removed. This was [deprecated in 8.0](upgrading-to-8).\n\nRemoval of Other Deprecated Features\n\nSeveral other methods/properties that were deprecated in FluentValidation 8 have been removed in 9.0.\n\n['`ReplacePlaceholderWithValue` and `GetPlaceholder` from `MesageFormatter`', '`ResourceName` and `ResourceType` have been removed from `IStringSource`.', '`ResourceName` has been removed from `ValidationFailure`.', '`Instance` was removed from `PropertyValidatorContext` - use `InstanceToValidate` instead.', '`DelegatingValidator` has been removed', '`FluentValidation.Internal.Comparer` has been removed', '`FluentValidation.Internal.TrackingCollection` is now internal']"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 29]"
    },
    {
      "title": "Webapi",
      "description": null,
      "content": {
        "ASP.NET WebApi 2": "```\n.. warning::\n   Integration with ASP.NET WebApi 2 is no longer supported as of FluentValidation 9. Please migrate to ASP.NET Core.\n```\n\nFluentValidation 8.x provided integration with ASP.NET Web Api 2. This is no longer maintained or supported, and is not compatible with FluentValidation 9 or newer.\n\nFor instructions on using these unsupported legacy components with FluentValidation 8, [please review this page](https://github.com/FluentValidation/FluentValidation-LegacyWeb/wiki/WebApi-2-Integration)"
      },
      "metadata": {},
      "subpages": [],
      "path": "[\"subpages\", 30]"
    }
  ]
}